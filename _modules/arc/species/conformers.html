

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>arc.species.conformers &mdash; ARC 1.1.0 Documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ARC
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../running.html">Running ARC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced.html">Advanced Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">ARCâ€™s API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools.html">Standalone tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">How to cite ARC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../licence.html">Licence</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ARC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>arc.species.conformers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for arc.species.conformers</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A module for (non-TS) species conformer generation</span>

<span class="sd">Note:</span>
<span class="sd">    variables that contain atom indices such as torsions and tops are 1-indexed,</span>
<span class="sd">    while atoms in Molecules are 0-indexed.</span>

<span class="sd">Todo:</span>
<span class="sd">    * Consider boat-chair conformers (https://en.wikipedia.org/wiki/Cyclohexane_conformation)</span>
<span class="sd">    * finally, consider h-bonds</span>
<span class="sd">    * Does it take the scan energy into account when generating combinations??</span>
<span class="sd">    * The secretary problem - incorporate for stochastic searching</span>
<span class="sd">    * What&#39;s the confirmed bottleneck?</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations_with_replacement</span>
<span class="kn">from</span> <span class="nn">heapq</span> <span class="k">import</span> <span class="n">nsmallest</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">rdkit</span> <span class="k">import</span> <span class="n">Chem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem.rdchem</span> <span class="k">import</span> <span class="n">EditableMol</span> <span class="k">as</span> <span class="n">RDMol</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem.rdmolops</span> <span class="k">import</span> <span class="n">AssignStereochemistry</span>
<span class="kn">import</span> <span class="nn">openbabel</span> <span class="k">as</span> <span class="nn">ob</span>
<span class="kn">import</span> <span class="nn">pybel</span> <span class="k">as</span> <span class="nn">pyb</span>

<span class="kn">from</span> <span class="nn">rmgpy.molecule.molecule</span> <span class="k">import</span> <span class="n">Molecule</span>
<span class="kn">from</span> <span class="nn">rmgpy.molecule.converter</span> <span class="k">import</span> <span class="n">toOBMol</span>
<span class="kn">import</span> <span class="nn">rmgpy.molecule.group</span> <span class="k">as</span> <span class="nn">gr</span>

<span class="kn">from</span> <span class="nn">arc.arc_exceptions</span> <span class="k">import</span> <span class="n">ConformerError</span>
<span class="kn">from</span> <span class="nn">arc.species</span> <span class="k">import</span> <span class="n">converter</span>
<span class="kn">from</span> <span class="nn">arc.common</span> <span class="k">import</span> <span class="n">logger</span><span class="p">,</span> <span class="n">determine_symmetry</span>
<span class="kn">import</span> <span class="nn">arc.plotter</span>

<span class="c1">##################################################################</span>


<span class="c1"># conformers is a list of dictionaries, each with the following keys:</span>
<span class="c1"># {&#39;xyz&#39;: &lt;str&gt;,</span>
<span class="c1">#  &#39;index&#39;: &lt;int&gt;,</span>
<span class="c1">#  &#39;FF energy&#39;: &lt;float&gt;,</span>
<span class="c1">#  &#39;source&#39;: &lt;str&gt;,</span>
<span class="c1">#  &#39;torsion_dihedrals&#39;: {&lt;torsion tuple 0&gt;: angle 0,</span>
<span class="c1">#                        &lt;torsion tuple 1&gt;: angle 1,</span>
<span class="c1">#  }</span>

<span class="c1"># Module workflow:</span>
<span class="c1"># generate_conformers</span>
<span class="c1">#     generate_force_field_conformers</span>
<span class="c1">#         get_force_field_energies, rdkit_force_field or mix_rdkit_and_openbabel_force_field, determine_dihedrals</span>
<span class="c1">#     deduce_new_conformers</span>
<span class="c1">#         get_torsion_angles, determine_torsion_symmetry, determine_torsion_sampling_points,</span>
<span class="c1">#         change_dihedrals_and_force_field_it</span>
<span class="c1">#     get_lowest_confs</span>

<span class="c1"># The number of conformers to generate per range of heavy atoms in the molecule</span>
<span class="n">CONFS_VS_HEAVY_ATOMS</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span>
                        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mi">5</span><span class="p">,</span>
                        <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="mi">100</span><span class="p">,</span>
                        <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">29</span><span class="p">):</span> <span class="mi">500</span><span class="p">,</span>
                        <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">59</span><span class="p">):</span> <span class="mi">1000</span><span class="p">,</span>
                        <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">99</span><span class="p">):</span> <span class="mi">5000</span><span class="p">,</span>
                        <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;inf&#39;</span><span class="p">):</span> <span class="mi">10000</span><span class="p">,</span>
                        <span class="p">}</span>

<span class="c1"># The number of conformers to generate per range of potential torsions in the molecule</span>
<span class="n">CONFS_VS_TORSIONS</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mi">10</span><span class="p">,</span>
                     <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="mi">50</span><span class="p">,</span>
                     <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">24</span><span class="p">):</span> <span class="mi">500</span><span class="p">,</span>
                     <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">49</span><span class="p">):</span> <span class="mi">5000</span><span class="p">,</span>
                     <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;inf&#39;</span><span class="p">):</span> <span class="mi">10000</span><span class="p">,</span>
                     <span class="p">}</span>

<span class="c1"># The resolution (in degrees) for scanning smeared wells</span>
<span class="n">SMEARED_SCAN_RESOLUTIONS</span> <span class="o">=</span> <span class="mf">30.0</span>

<span class="c1"># The number of conformers to return. Will be iteratively checked for consistency. The rest will be written to a file.</span>
<span class="n">NUM_CONFS_TO_RETURN</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1"># An energy threshold (in kJ/mol) above which wells in a torsion will not be considered (rel. to the most stable well)</span>
<span class="n">DE_THRESHOLD</span> <span class="o">=</span> <span class="mf">5.</span>

<span class="c1"># The gap (in degrees) that defines different wells</span>
<span class="n">WELL_GAP</span> <span class="o">=</span> <span class="mi">20</span>

<span class="c1"># The maximum number of times to iteratively search for the lowest conformer</span>
<span class="n">MAX_COMBINATION_ITERATIONS</span> <span class="o">=</span> <span class="mi">25</span>

<span class="c1"># A threshold below which all combinations will be generated. Above it just samples of the entire search space.</span>
<span class="n">COMBINATION_THRESHOLD</span> <span class="o">=</span> <span class="mi">1000</span>


<div class="viewcode-block" id="generate_conformers"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.generate_conformers">[docs]</a><span class="k">def</span> <span class="nf">generate_conformers</span><span class="p">(</span><span class="n">mol_list</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">xyzs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">torsions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_confs_to_return</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">well_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">de_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">smeared_scan_res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">combination_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">,</span>
                        <span class="n">max_combination_iterations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">determine_h_bonds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_all_conformers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">plot_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_logs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate conformers for (non-TS) species starting from a list of RMG Molecules.</span>
<span class="sd">    (resonance structures are assumed to have already been generated and included in the molecule list)</span>

<span class="sd">    Args:</span>
<span class="sd">        mol_list (list or Molecule): Molecule objects to consider (or Molecule, resonance structures will be generated).</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        xyzs (list), optional: A list of user guess xyzs, each in string format, that will also be taken into account.</span>
<span class="sd">        torsions (list, optional): A list of all possible torsions in the molecule. Will be determined if not given.</span>
<span class="sd">        tops (list, optional): A list of tops corresponding to torsions. Will be determined if not given.</span>
<span class="sd">        charge (int, optional): The species charge. Used to perceive a molecule from xyz.</span>
<span class="sd">        multiplicity (int, optional): The species multiplicity. Used to perceive a molecule from xyz.</span>
<span class="sd">        num_confs (int, optional): The number of conformers to generate. Determined automatically if not given.</span>
<span class="sd">        num_confs_to_return (int, optional): The number of conformers to return.</span>
<span class="sd">        well_tolerance (float, optional): The required precision (in degrees) around which to center a well&#39;s mean.</span>
<span class="sd">        de_threshold (float, optional): Energy threshold (in kJ/mol) above which wells will not be considered.</span>
<span class="sd">        smeared_scan_res (float, optional): The resolution (in degrees) for scanning smeared wells.</span>
<span class="sd">        combination_threshold (int, optional): A threshold below which all combinations will be generated.</span>
<span class="sd">        force_field (str, optional): The type of force field to use (MMFF94, MMFF94s, UFF, GAFF, fit).</span>
<span class="sd">                                       &#39;fit&#39; will first run MMFF94, than fit a custom Amber FF to the species.</span>
<span class="sd">        max_combination_iterations (int, optional): The maximum number of times to iteratively search</span>
<span class="sd">                                                    for the lowest conformer.</span>
<span class="sd">        determine_h_bonds (bool, optional): Whether to determine add. conformers w/ hydrogen bonds from the lowest one.</span>
<span class="sd">        return_all_conformers (bool, optional): Whether to return the full conformers list of conformer dictionaries</span>
<span class="sd">                                                In addition to the lowest conformers list. Tru to return it.</span>
<span class="sd">        plot_path (str, optional): A folder path in which the plot will be saved.</span>
<span class="sd">                                     If None, the plot will not be shown (nor saved).</span>
<span class="sd">        print_logs (bool, optional): Whether define a logger so logs are also printed to stdout.</span>
<span class="sd">                                     Useful when run outside of ARC. True to print.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Lowest conformers (number of entries is num_confs_to_return times the number of enantiomer combinations)</span>

<span class="sd">    Raises:</span>
<span class="sd">        ConformerError: If something goes wrong.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">print_logs</span><span class="p">:</span>
        <span class="n">initialize_log</span><span class="p">()</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating conformers for </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>

    <span class="n">num_confs_to_return</span> <span class="o">=</span> <span class="n">num_confs_to_return</span> <span class="ow">or</span> <span class="n">NUM_CONFS_TO_RETURN</span>
    <span class="n">max_combination_iterations</span> <span class="o">=</span> <span class="n">max_combination_iterations</span> <span class="ow">or</span> <span class="n">MAX_COMBINATION_ITERATIONS</span>
    <span class="n">combination_threshold</span> <span class="o">=</span> <span class="n">combination_threshold</span> <span class="ow">or</span> <span class="n">COMBINATION_THRESHOLD</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol_list</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">):</span>
        <span class="n">mol_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">mol</span> <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mol_list</span><span class="o">.</span><span class="n">generate_resonance_structures</span><span class="p">()</span> <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">reactive</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;The `mol_list` argument must be a list, got </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mol_list</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mol_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Each entry in the `mol_list` argument must be an RMG Molecule object, &#39;</span>
                                 <span class="s1">&#39;got </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mol</span><span class="p">)))</span>
    <span class="n">mol_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">update_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mol_list</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">torsions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">tops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">torsions</span><span class="p">,</span> <span class="n">tops</span> <span class="o">=</span> <span class="n">determine_rotors</span><span class="p">(</span><span class="n">mol_list</span><span class="p">)</span>
    <span class="n">conformers</span> <span class="o">=</span> <span class="n">generate_force_field_conformers</span><span class="p">(</span><span class="n">mol_list</span><span class="o">=</span><span class="n">mol_list</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">xyzs</span><span class="o">=</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">torsion_num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">torsions</span><span class="p">),</span>
                                                 <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="n">multiplicity</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="n">num_confs</span><span class="p">,</span>
                                                 <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">)</span>

    <span class="n">conformers</span> <span class="o">=</span> <span class="n">determine_dihedrals</span><span class="p">(</span><span class="n">conformers</span><span class="p">,</span> <span class="n">torsions</span><span class="p">)</span>

    <span class="n">base_xyz</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">torsion_angles</span><span class="p">,</span> <span class="n">multiple_sampling_points_dict</span><span class="p">,</span>\
        <span class="n">wells_dict</span><span class="p">,</span> <span class="n">hypothetical_num_comb</span> <span class="o">=</span> <span class="n">deduce_new_conformers</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">torsions</span><span class="p">,</span> <span class="n">tops</span><span class="p">,</span> <span class="n">mol_list</span><span class="p">,</span>
                                                                  <span class="n">smeared_scan_res</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="n">plot_path</span><span class="p">)</span>

    <span class="n">new_conformers</span> <span class="o">=</span> <span class="n">generate_conformer_combinations</span><span class="p">(</span>
        <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">base_xyz</span><span class="o">=</span><span class="n">base_xyz</span><span class="p">,</span> <span class="n">hypothetical_num_comb</span><span class="o">=</span><span class="n">hypothetical_num_comb</span><span class="p">,</span>
        <span class="n">multiple_tors</span><span class="o">=</span><span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="o">=</span><span class="n">multiple_sampling_points</span><span class="p">,</span>
        <span class="n">combination_threshold</span><span class="o">=</span><span class="n">combination_threshold</span><span class="p">,</span> <span class="n">len_conformers</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">),</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span>
        <span class="n">max_combination_iterations</span><span class="o">=</span><span class="n">max_combination_iterations</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="n">plot_path</span><span class="p">,</span> <span class="n">torsion_angles</span><span class="o">=</span><span class="n">torsion_angles</span><span class="p">,</span>
        <span class="n">multiple_sampling_points_dict</span><span class="o">=</span><span class="n">multiple_sampling_points_dict</span><span class="p">,</span> <span class="n">wells_dict</span><span class="o">=</span><span class="n">wells_dict</span><span class="p">,</span> <span class="n">de_threshold</span><span class="o">=</span><span class="n">de_threshold</span><span class="p">)</span>

    <span class="n">conformers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_conformers</span><span class="p">)</span>

    <span class="n">num_confs_to_return</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_confs_to_return</span><span class="p">,</span> <span class="n">hypothetical_num_comb</span><span class="p">)</span>  <span class="c1"># don&#39;t return more than we have</span>
    <span class="n">lowest_confs</span> <span class="o">=</span> <span class="n">get_lowest_confs</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">num_confs_to_return</span><span class="p">)</span>

    <span class="n">lowest_conf</span> <span class="o">=</span> <span class="n">get_lowest_confs</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">enantiomeric_xyzs</span> <span class="o">=</span> <span class="n">generate_all_enantiomers</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xyz</span><span class="o">=</span><span class="n">lowest_conf</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">enantiomeric_xyz</span> <span class="ow">in</span> <span class="n">enantiomeric_xyzs</span><span class="p">:</span>
        <span class="n">new_conformers</span> <span class="o">=</span> <span class="n">generate_conformer_combinations</span><span class="p">(</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">base_xyz</span><span class="o">=</span><span class="n">enantiomeric_xyz</span><span class="p">,</span> <span class="n">hypothetical_num_comb</span><span class="o">=</span><span class="n">hypothetical_num_comb</span><span class="p">,</span>
            <span class="n">multiple_tors</span><span class="o">=</span><span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="o">=</span><span class="n">multiple_sampling_points</span><span class="p">,</span>
            <span class="n">combination_threshold</span><span class="o">=</span><span class="n">combination_threshold</span><span class="p">,</span> <span class="n">len_conformers</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">),</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span>
            <span class="n">max_combination_iterations</span><span class="o">=</span><span class="n">max_combination_iterations</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="n">plot_path</span><span class="p">,</span> <span class="n">torsion_angles</span><span class="o">=</span><span class="n">torsion_angles</span><span class="p">,</span>
            <span class="n">multiple_sampling_points_dict</span><span class="o">=</span><span class="n">multiple_sampling_points_dict</span><span class="p">,</span> <span class="n">wells_dict</span><span class="o">=</span><span class="n">wells_dict</span><span class="p">,</span>
            <span class="n">de_threshold</span><span class="o">=</span><span class="n">de_threshold</span><span class="p">)</span>
        <span class="n">conformers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_conformers</span><span class="p">)</span>
        <span class="n">lowest_confs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_lowest_confs</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">new_conformers</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">num_confs_to_return</span><span class="p">))</span>

    <span class="n">lowest_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;FF energy&#39;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># sort by output confs from lowest to highest energy</span>
    <span class="n">indices_to_pop</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">conf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lowest_confs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">compare_xyz</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">],</span> <span class="n">lowest_confs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;xyz&#39;</span><span class="p">]):</span>
            <span class="n">indices_to_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lowest_confs</span><span class="p">))):</span>  <span class="c1"># pop from the end, so other indices won&#39;t change</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_to_pop</span><span class="p">:</span>
            <span class="n">lowest_confs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">execution_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">execution_time</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
    <span class="n">days</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> days and &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">if</span> <span class="n">d</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="n">time_str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{days}{hrs:02d}</span><span class="s1">:</span><span class="si">{min:02d}</span><span class="s1">:</span><span class="si">{sec:02d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">days</span><span class="p">,</span> <span class="n">hrs</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">sec</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">execution_time</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Conformer execution time using </span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">force_field</span><span class="p">,</span> <span class="n">time_str</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_all_conformers</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lowest_confs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lowest_confs</span><span class="p">,</span> <span class="n">conformers</span></div>


<div class="viewcode-block" id="deduce_new_conformers"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.deduce_new_conformers">[docs]</a><span class="k">def</span> <span class="nf">deduce_new_conformers</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">torsions</span><span class="p">,</span> <span class="n">tops</span><span class="p">,</span> <span class="n">mol_list</span><span class="p">,</span> <span class="n">smeared_scan_res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    By knowing the existing torsion wells, get the geometries of all important conformers.</span>
<span class="sd">    Validate that atoms don&#39;t collide in the generated conformers (don&#39;t consider ones where they do).</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        conformers (list): Entries are conformer dictionaries.</span>
<span class="sd">        torsions (list): A list of all possible torsion angles in the molecule, each torsion angles list is sorted.</span>
<span class="sd">        tops (list): A list of tops corresponding to torsions.</span>
<span class="sd">        mol_list (list): A list of RMG Molecule objects.</span>
<span class="sd">        smeared_scan_res (float, optional): The resolution (in degrees) for scanning smeared wells.</span>
<span class="sd">        plot_path (str, optional): A folder path in which the plot will be saved.</span>
<span class="sd">                                     If None, the plot will not be shown (nor saved).</span>

<span class="sd">    Returns:</span>
<span class="sd">        many inter-level variables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smeared_scan_res</span> <span class="o">=</span> <span class="n">smeared_scan_res</span> <span class="ow">or</span> <span class="n">SMEARED_SCAN_RESOLUTIONS</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;torsion_dihedrals&#39;</span> <span class="ow">in</span> <span class="n">conformer</span> <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">conformers</span><span class="p">]):</span>
        <span class="n">conformers</span> <span class="o">=</span> <span class="n">determine_dihedrals</span><span class="p">(</span><span class="n">conformers</span><span class="p">,</span> <span class="n">torsions</span><span class="p">)</span>
    <span class="n">torsion_angles</span> <span class="o">=</span> <span class="n">get_torsion_angles</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">torsions</span><span class="p">)</span>  <span class="c1"># get all wells per torsion</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">mol_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">symmetries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">torsion</span><span class="p">,</span> <span class="n">top</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">torsions</span><span class="p">,</span> <span class="n">tops</span><span class="p">):</span>
        <span class="c1"># identify symmetric torsions so we don&#39;t bother considering them in the conformational combinations</span>
        <span class="n">symmetry</span> <span class="o">=</span> <span class="n">determine_torsion_symmetry</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">mol_list</span><span class="p">,</span> <span class="n">torsion_angles</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)])</span>
        <span class="n">symmetries</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)]</span> <span class="o">=</span> <span class="n">symmetry</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Identified </span><span class="si">{0}</span><span class="s1"> symmetric wells for </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symmetries</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">label</span><span class="p">))</span>

    <span class="n">torsions_sampling_points</span><span class="p">,</span> <span class="n">wells_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tor</span><span class="p">,</span> <span class="n">tor_angles</span> <span class="ow">in</span> <span class="n">torsion_angles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">torsions_sampling_points</span><span class="p">[</span><span class="n">tor</span><span class="p">],</span> <span class="n">wells_dict</span><span class="p">[</span><span class="n">tor</span><span class="p">]</span> <span class="o">=</span>\
            <span class="n">determine_torsion_sampling_points</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">tor_angles</span><span class="p">,</span> <span class="n">smeared_scan_res</span><span class="o">=</span><span class="n">smeared_scan_res</span><span class="p">,</span>
                                              <span class="n">symmetry</span><span class="o">=</span><span class="n">symmetries</span><span class="p">[</span><span class="n">tor</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">plot_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arc</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_torsion_angles</span><span class="p">(</span><span class="n">torsion_angles</span><span class="p">,</span> <span class="n">torsions_sampling_points</span><span class="p">,</span> <span class="n">wells_dict</span><span class="o">=</span><span class="n">wells_dict</span><span class="p">,</span>
                                        <span class="n">plot_path</span><span class="o">=</span><span class="n">plot_path</span><span class="p">)</span>

    <span class="n">hypothetical_num_comb</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">torsions_sampling_points</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">hypothetical_num_comb</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hypothetical_num_comb</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
        <span class="n">hypothetical_num_comb_str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:.2E}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hypothetical_num_comb</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hypothetical_num_comb_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">hypothetical_num_comb</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Hypothetical number of conformer combinations for </span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">hypothetical_num_comb_str</span><span class="p">))</span>

    <span class="c1"># get the lowest conformer as the base xyz for further processing</span>
    <span class="n">lowest_conf</span> <span class="o">=</span> <span class="n">get_lowest_confs</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># split torsions_sampling_points into two lists, use combinations only for those with multiple sampling points</span>
    <span class="n">single_tors</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="p">,</span> <span class="n">single_sampling_point</span><span class="p">,</span> <span class="n">multiple_sampling_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">multiple_sampling_points_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># used for plotting an energy &quot;scan&quot;</span>
    <span class="k">for</span> <span class="n">tor</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">torsions_sampling_points</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">single_tors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tor</span><span class="p">)</span>
            <span class="n">single_sampling_point</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">multiple_sampling_points_dict</span><span class="p">[</span><span class="n">tor</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span>
            <span class="n">multiple_tors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tor</span><span class="p">)</span>
            <span class="n">multiple_sampling_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

    <span class="c1"># set symmetric (single well) torsions to the mean of the well</span>
    <span class="n">base_xyz</span> <span class="o">=</span> <span class="n">lowest_conf</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">]</span>  <span class="c1"># base_xyz is modified within the loop in each iteration</span>
    <span class="k">if</span> <span class="n">plot_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;original lowest conformer for </span><span class="si">{0}</span><span class="s1">:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
        <span class="n">arc</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">show_sticks</span><span class="p">(</span><span class="n">base_xyz</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">torsion</span><span class="p">,</span> <span class="n">dihedral</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">single_tors</span><span class="p">,</span> <span class="n">single_sampling_point</span><span class="p">):</span>
        <span class="n">conf</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">index_map</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">rdkit_conf_from_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">base_xyz</span><span class="p">)</span>
        <span class="n">rd_tor_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">torsion</span><span class="p">]</span>  <span class="c1"># convert the atom indices in the torsion to RDKit indices</span>
        <span class="n">base_xyz</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">set_rdkit_dihedrals</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">index_map</span><span class="p">,</span> <span class="n">rd_tor_map</span><span class="p">,</span> <span class="n">deg_abs</span><span class="o">=</span><span class="n">dihedral</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">base_xyz</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">torsion_angles</span><span class="p">,</span>\
        <span class="n">multiple_sampling_points_dict</span><span class="p">,</span> <span class="n">wells_dict</span><span class="p">,</span> <span class="n">hypothetical_num_comb</span></div>


<div class="viewcode-block" id="generate_conformer_combinations"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.generate_conformer_combinations">[docs]</a><span class="k">def</span> <span class="nf">generate_conformer_combinations</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">base_xyz</span><span class="p">,</span> <span class="n">hypothetical_num_comb</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="p">,</span>
                                    <span class="n">multiple_sampling_points</span><span class="p">,</span> <span class="n">combination_threshold</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">len_conformers</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">,</span> <span class="n">max_combination_iterations</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">torsion_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiple_sampling_points_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wells_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">de_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call either conformers_combinations_by_lowest_conformer() or generate_all_combinations(),</span>
<span class="sd">    according to the hypothetical_num_comb.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The RMG molecule with the connectivity information.</span>
<span class="sd">        base_xyz (str, or list): The base 3D geometry to be changed, in either string or array format.</span>
<span class="sd">        hypothetical_num_comb (int): The number of combinations that could be generated by changing dihedrals,</span>
<span class="sd">                                     considering symmetry but not considering atom collisions.</span>
<span class="sd">        combination_threshold (int, optional): A threshold below which all combinations will be generated.</span>
<span class="sd">        multiple_tors (list): Entries are torsion tuples of non-symmetric torsions.</span>
<span class="sd">        multiple_sampling_points (list): Entries are lists of dihedral angles (sampling points), respectively correspond</span>
<span class="sd">                                         to torsions in multiple_tors.</span>
<span class="sd">        len_conformers (int, optional): The length of the existing conformers list (for consecutive numbering).</span>
<span class="sd">        de_threshold (float, optional): An energy threshold (in kJ/mol) above which wells in a torsion</span>
<span class="sd">                                        will not be considered.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>
<span class="sd">        max_combination_iterations (int, optional): The max num of times to iteratively search for the lowest conformer.</span>
<span class="sd">        torsion_angles (dict, optional): The torsion angles. Keys are torsion tuples, values are lists of all</span>
<span class="sd">                                         corresponding angles from conformers.</span>
<span class="sd">        multiple_sampling_points_dict (dict, optional): Keys are torsion tuples, values are respective sampling points.</span>
<span class="sd">        wells_dict (dict, optional): Keys are torsion tuples, values are well dictionaries.</span>
<span class="sd">        plot_path (str, optional): A folder path in which the plot will be saved.</span>
<span class="sd">                                            If None, the plot will not be shown (nor saved).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: New conformer combinations, entries are conformer dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">de_threshold</span> <span class="o">=</span> <span class="n">de_threshold</span> <span class="ow">or</span> <span class="n">DE_THRESHOLD</span>
    <span class="k">if</span> <span class="n">hypothetical_num_comb</span> <span class="o">&gt;</span> <span class="n">combination_threshold</span><span class="p">:</span>
        <span class="c1"># don&#39;t generate all combinations, there are simply too many</span>
        <span class="c1"># iteratively modify the lowest conformer until it converges.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;hypothetical_num_comb for </span><span class="si">{0}</span><span class="s1"> is &gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">combination_threshold</span><span class="p">))</span>
        <span class="n">new_conformers</span> <span class="o">=</span> <span class="n">conformers_combinations_by_lowest_conformer</span><span class="p">(</span>
            <span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">base_xyz</span><span class="o">=</span><span class="n">base_xyz</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="o">=</span><span class="n">multiple_tors</span><span class="p">,</span>
            <span class="n">multiple_sampling_points</span><span class="o">=</span><span class="n">multiple_sampling_points</span><span class="p">,</span> <span class="n">len_conformers</span><span class="o">=</span><span class="n">len_conformers</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span>
            <span class="n">plot_path</span><span class="o">=</span><span class="n">plot_path</span><span class="p">,</span> <span class="n">de_threshold</span><span class="o">=</span><span class="n">de_threshold</span><span class="p">,</span> <span class="n">max_combination_iterations</span><span class="o">=</span><span class="n">max_combination_iterations</span><span class="p">,</span>
            <span class="n">torsion_angles</span><span class="o">=</span><span class="n">torsion_angles</span><span class="p">,</span> <span class="n">multiple_sampling_points_dict</span><span class="o">=</span><span class="n">multiple_sampling_points_dict</span><span class="p">,</span>
            <span class="n">wells_dict</span><span class="o">=</span><span class="n">wells_dict</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># just generate all combinations and get their FF energies</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;hypothetical_num_comb for </span><span class="si">{0}</span><span class="s1"> is &lt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">combination_threshold</span><span class="p">))</span>
        <span class="n">new_conformers</span> <span class="o">=</span> <span class="n">generate_all_combinations</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">base_xyz</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="p">,</span>
                                                   <span class="n">len_conformers</span><span class="o">=</span><span class="n">len_conformers</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_conformers</span></div>


<div class="viewcode-block" id="conformers_combinations_by_lowest_conformer"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.conformers_combinations_by_lowest_conformer">[docs]</a><span class="k">def</span> <span class="nf">conformers_combinations_by_lowest_conformer</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">base_xyz</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="p">,</span>
                                                <span class="n">len_conformers</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">,</span> <span class="n">max_combination_iterations</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                                                <span class="n">torsion_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiple_sampling_points_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="n">wells_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">de_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iteratively modify dihedrals in the lowest conformer (each iteration deduce the new lowest conformer),</span>
<span class="sd">    until convergence.</span>
<span class="sd">    untested</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The RMG molecule with the connectivity information.</span>
<span class="sd">        base_xyz (str, or list): The base 3D geometry to be changed, in either string or array format.</span>
<span class="sd">        multiple_tors (list): Entries are torsion tuples of non-symmetric torsions.</span>
<span class="sd">        multiple_sampling_points (list): Entries are lists of dihedral angles (sampling points), respectively correspond</span>
<span class="sd">                                         to torsions in multiple_tors.</span>
<span class="sd">        len_conformers (int, optional): The length of the existing conformers list (for consecutive numbering).</span>
<span class="sd">        de_threshold (float, optional): An energy threshold (in kJ/mol) above which wells in a torsion</span>
<span class="sd">                                        will not be considered.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>
<span class="sd">        max_combination_iterations (int, optional): The max num of times to iteratively search for the lowest conformer.</span>
<span class="sd">        torsion_angles (dict, optional): The torsion angles. Keys are torsion tuples, values are lists of all</span>
<span class="sd">                                         corresponding angles from conformers.</span>
<span class="sd">        multiple_sampling_points_dict (dict, optional): Keys are torsion tuples, values are respective sampling points.</span>
<span class="sd">        wells_dict (dict, optional): Keys are torsion tuples, values are well dictionaries.</span>
<span class="sd">        plot_path (str, optional): A folder path in which the plot will be saved.</span>
<span class="sd">                                            If None, the plot will not be shown (nor saved).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: New conformer combinations, entries are conformer dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">base_xyz</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_xyz</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">base_xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">base_energy</span> <span class="o">=</span> <span class="n">get_force_field_energies</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                                           <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">new_conformers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># will be returned</span>
    <span class="n">lowest_conf_i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_combination_iterations</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;iteration </span><span class="si">{0}</span><span class="s1"> for </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
        <span class="n">newest_conformers_dict</span><span class="p">,</span> <span class="n">newest_conformer_list</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># conformers from the current iteration</span>
        <span class="k">for</span> <span class="n">tor</span><span class="p">,</span> <span class="n">sampling_points</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="p">):</span>
            <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="n">change_dihedrals_and_force_field_it</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">torsions</span><span class="o">=</span><span class="p">[</span><span class="n">tor</span><span class="p">],</span>
                                                                 <span class="n">new_dihedrals</span><span class="o">=</span><span class="p">[[</span><span class="n">sp</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">sampling_points</span><span class="p">],</span>
                                                                 <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">newest_conformers_dict</span><span class="p">[</span><span class="n">tor</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># keys are torsions for plotting</span>
            <span class="k">for</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">dihedral</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="n">sampling_points</span><span class="p">):</span>
                <span class="n">exists</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">new_conformers</span> <span class="o">+</span> <span class="n">newest_conformer_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">compare_xyz</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">conf</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">]):</span>
                        <span class="n">exists</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">conformer</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">len_conformers</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_conformers</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">newest_conformer_list</span><span class="p">),</span>
                                 <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> <span class="n">xyz</span><span class="p">,</span>
                                 <span class="s1">&#39;FF energy&#39;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                                 <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="s1">&#39;Changing dihedrals on most stable conformer, iteration </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                                 <span class="s1">&#39;torsion&#39;</span><span class="p">:</span> <span class="n">tor</span><span class="p">,</span>
                                 <span class="s1">&#39;dihedral&#39;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">dihedral</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
                    <span class="n">newest_conformers_dict</span><span class="p">[</span><span class="n">tor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">:</span>
                        <span class="n">newest_conformer_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conformer</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if xyz is None, atoms have collided</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">atoms colliding in </span><span class="si">{0}</span><span class="s1"> for torsion </span><span class="si">{1}</span><span class="s1"> and dihedral </span><span class="si">{2}</span><span class="s1">:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">label</span><span class="p">,</span> <span class="n">tor</span><span class="p">,</span> <span class="n">dihedral</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">new_conformers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">newest_conformer_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">newest_conformer_list</span><span class="p">:</span>
            <span class="n">newest_conformer_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">lowest_conf_i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">force_field</span> <span class="o">!=</span> <span class="s1">&#39;gromacs&#39;</span><span class="p">:</span>
            <span class="n">lowest_conf_i</span> <span class="o">=</span> <span class="n">get_lowest_confs</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">newest_conformer_list</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">lowest_conf_i</span><span class="p">[</span><span class="s1">&#39;FF energy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">base_energy</span>\
                    <span class="ow">and</span> <span class="n">compare_xyz</span><span class="p">(</span><span class="n">lowest_conf_i</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">],</span> <span class="n">base_xyz</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">lowest_conf_i</span><span class="p">[</span><span class="s1">&#39;FF energy&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">base_energy</span><span class="p">:</span>
                <span class="n">base_energy</span> <span class="o">=</span> <span class="n">lowest_conf_i</span><span class="p">[</span><span class="s1">&#39;FF energy&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">plot_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arc</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">show_sticks</span><span class="p">(</span><span class="n">lowest_conf_i</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">])</span>
        <span class="n">num_comb</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_torsion_angles</span><span class="p">(</span><span class="n">torsion_angles</span><span class="p">,</span> <span class="n">multiple_sampling_points_dict</span><span class="p">,</span>
                                                   <span class="n">wells_dict</span><span class="o">=</span><span class="n">wells_dict</span><span class="p">,</span> <span class="n">e_conformers</span><span class="o">=</span><span class="n">newest_conformers_dict</span><span class="p">,</span>
                                                   <span class="n">de_threshold</span><span class="o">=</span><span class="n">de_threshold</span><span class="p">,</span> <span class="n">plot_path</span><span class="o">=</span><span class="n">plot_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_comb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_comb</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">num_comb_str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:.2E}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_comb</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_comb_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_comb</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Number of conformer combinations for </span><span class="si">{0}</span><span class="s1"> after reduction: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">num_comb_str</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">de_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_e</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;FF energy&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">new_conformers</span><span class="p">])</span>
        <span class="n">new_conformers</span> <span class="o">=</span> <span class="p">[</span><span class="n">conf</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">new_conformers</span> <span class="k">if</span> <span class="n">conf</span><span class="p">[</span><span class="s1">&#39;FF energy&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_e</span> <span class="o">&lt;</span> <span class="n">de_threshold</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_conformers</span></div>


<div class="viewcode-block" id="generate_all_combinations"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.generate_all_combinations">[docs]</a><span class="k">def</span> <span class="nf">generate_all_combinations</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">base_xyz</span><span class="p">,</span> <span class="n">multiple_tors</span><span class="p">,</span> <span class="n">multiple_sampling_points</span><span class="p">,</span> <span class="n">len_conformers</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all combinations of torsion wells from a base conformer.</span>
<span class="sd">    untested</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The RMG molecule with the connectivity information.</span>
<span class="sd">        base_xyz (str, or list): The base 3D geometry to be changed, in either string or array format.</span>
<span class="sd">        multiple_tors (list): Entries are torsion tuples of non-symmetric torsions.</span>
<span class="sd">        multiple_sampling_points (list): Entries are lists of dihedral angles (sampling points), respectively correspond</span>
<span class="sd">                                         to torsions in multiple_tors.</span>
<span class="sd">        len_conformers (int, optional): The length of the existing conformers list (for consecutive numbering).</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: New conformer combinations, entries are conformer dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">base_xyz</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_xyz</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">base_xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># generate sampling points combinations</span>
    <span class="n">product_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">multiple_sampling_points</span><span class="p">))</span>
    <span class="n">new_conformers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># will be returned</span>

    <span class="k">if</span> <span class="n">multiple_tors</span><span class="p">:</span>
        <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="n">change_dihedrals_and_force_field_it</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">torsions</span><span class="o">=</span><span class="n">multiple_tors</span><span class="p">,</span>
                                                             <span class="n">new_dihedrals</span><span class="o">=</span><span class="n">product_combinations</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                             <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">energy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_conformers</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">len_conformers</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_conformers</span><span class="p">),</span>
                                       <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> <span class="n">xyz</span><span class="p">,</span>
                                       <span class="s1">&#39;FF energy&#39;</span><span class="p">:</span> <span class="n">energy</span><span class="p">,</span>
                                       <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="s1">&#39;Generated all combinations from scan map&#39;</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># no multiple torsions (all torsions are symmetric or no torsions in the molecule), this is a trivial case</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_string</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">)</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">get_force_field_energies</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span>
                                          <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_conformers</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">len_conformers</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_conformers</span><span class="p">),</span>
                               <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_string</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">),</span>
                               <span class="s1">&#39;FF energy&#39;</span><span class="p">:</span> <span class="n">energy</span><span class="p">,</span>
                               <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="s1">&#39;Generated all combinations from scan map (trivial case)&#39;</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">new_conformers</span></div>


<div class="viewcode-block" id="generate_force_field_conformers"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.generate_force_field_conformers">[docs]</a><span class="k">def</span> <span class="nf">generate_force_field_conformers</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol_list</span><span class="p">,</span> <span class="n">torsion_num</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="n">xyzs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate conformers using RDKit and Open Babel and optimize them using a force field</span>
<span class="sd">    Also consider user guesses in `xyzs`</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol_list (list): Entries are Molecule objects representing resonance structures of a chemical species.</span>
<span class="sd">        xyzs (list, optional): Entries are xyz coordinates in string format, given as initial guesses.</span>
<span class="sd">        torsion_num (int): The number of torsions identified in the molecule.</span>
<span class="sd">        charge (int): The net charge of the species.</span>
<span class="sd">        multiplicity (int): The species spin multiplicity.</span>
<span class="sd">        num_confs (int, optional): The number of conformers to generate.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are conformer dictionaries.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ConformerError: If xyzs is given and it is not a list, or its entries are not strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conformers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">number_of_heavy_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">isNonHydrogen</span><span class="p">()])</span>
    <span class="n">num_confs</span> <span class="o">=</span> <span class="n">num_confs</span> <span class="ow">or</span> <span class="n">determine_number_of_conformers_to_generate</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">heavy_atoms</span><span class="o">=</span><span class="n">number_of_heavy_atoms</span><span class="p">,</span>
                                                                        <span class="n">torsion_num</span><span class="o">=</span><span class="n">torsion_num</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Species </span><span class="si">{0}</span><span class="s1"> has </span><span class="si">{1}</span><span class="s1"> heavy atoms and </span><span class="si">{2}</span><span class="s1"> torsions. Using </span><span class="si">{3}</span><span class="s1"> random conformers.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">label</span><span class="p">,</span> <span class="n">number_of_heavy_atoms</span><span class="p">,</span> <span class="n">torsion_num</span><span class="p">,</span> <span class="n">num_confs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mol_list</span><span class="p">:</span>
        <span class="n">ff_xyzs</span><span class="p">,</span> <span class="n">ff_energies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ff_xyzs</span><span class="p">,</span> <span class="n">ff_energies</span> <span class="o">=</span> <span class="n">get_force_field_energies</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="n">num_confs</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                            <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not generate conformers for </span><span class="si">{0}</span><span class="s1">, failed with: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ff_xyzs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">energy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ff_xyzs</span><span class="p">,</span> <span class="n">ff_energies</span><span class="p">):</span>
                <span class="n">conformers</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;xyz&#39;</span><span class="p">:</span> <span class="n">xyz</span><span class="p">,</span>
                                   <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">),</span>
                                   <span class="s1">&#39;FF energy&#39;</span><span class="p">:</span> <span class="n">energy</span><span class="p">,</span>
                                   <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="n">force_field</span><span class="p">})</span>
    <span class="c1"># User guesses</span>
    <span class="k">if</span> <span class="n">xyzs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xyzs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyzs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;The xyzs argument must be a list, got </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">xyzs</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">xyzs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Each entry in xyzs must be a string, got </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">xyz</span><span class="p">)))</span>
            <span class="n">s_mol</span><span class="p">,</span> <span class="n">b_mol</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">molecules_from_xyz</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="n">multiplicity</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">)</span>
            <span class="n">conformers</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;xyz&#39;</span><span class="p">:</span> <span class="n">xyz</span><span class="p">,</span>
                               <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">conformers</span><span class="p">),</span>
                               <span class="s1">&#39;FF energy&#39;</span><span class="p">:</span> <span class="n">get_force_field_energies</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">b_mol</span> <span class="ow">or</span> <span class="n">s_mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
                                                                     <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                     <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                               <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="s1">&#39;User Guess&#39;</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">conformers</span></div>


<div class="viewcode-block" id="change_dihedrals_and_force_field_it"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.change_dihedrals_and_force_field_it">[docs]</a><span class="k">def</span> <span class="nf">change_dihedrals_and_force_field_it</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">torsions</span><span class="p">,</span> <span class="n">new_dihedrals</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                        <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change dihedrals of specified torsions according to the new dihedrals specified, and get FF energies.</span>

<span class="sd">    Example::</span>

<span class="sd">        torsions = [(1, 2, 3, 4), (9, 4, 7, 1)]</span>
<span class="sd">        new_dihedrals = [[90, 120], [90, 300], [180, 270], [30, 270]]</span>

<span class="sd">    This will calculate the energy of the original conformer (defined using `xyz`).</span>
<span class="sd">    We iterate through new_dihedrals. The torsions are set accordingly and the energy and xyz of the newly</span>
<span class="sd">    generated conformer are kept.</span>

<span class="sd">    We assume that each list entry in new_dihedrals is of the length of the torsions list (2 in the example).</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The RMG molecule with the connectivity information.</span>
<span class="sd">        xyz (str, or list): The base 3D geometry to be changed, in either string or array format.</span>
<span class="sd">        torsions (list): Entries are torsion tuples for which the dihedral will be changed relative to xyz.</span>
<span class="sd">        new_dihedrals (list): Entries are same size lists of dihedral angles (floats) corresponding to the torsions.</span>
<span class="sd">        optimize (bool, optional): Whether to optimize the coordinates using FF. True to optimize.</span>
<span class="sd">        return_xyz_strings (bool, optional): Whether to return xyz in string or array format. True for string.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: The conformer FF energies corresponding to the list of dihedrals.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: The conformer xyz geometries corresponding to the list of dihedrals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">torsions</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_dihedrals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">get_force_field_energies</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                               <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">energy</span>

    <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># make sure new_dihedrals is a list of lists (or tuples):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_dihedrals</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">new_dihedrals</span> <span class="o">=</span> <span class="p">[[</span><span class="n">new_dihedrals</span><span class="p">]]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_dihedrals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_dihedrals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">new_dihedrals</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_dihedrals</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">dihedrals</span> <span class="ow">in</span> <span class="n">new_dihedrals</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">torsion</span><span class="p">,</span> <span class="n">dihedral</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">torsions</span><span class="p">,</span> <span class="n">dihedrals</span><span class="p">):</span>
            <span class="n">conf</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">index_map</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">rdkit_conf_from_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>
            <span class="n">rd_torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_map</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">torsion</span><span class="p">]</span>  <span class="c1"># convert the atom indices in the torsion to RDKit indices</span>
            <span class="n">xyz_dihedrals</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">set_rdkit_dihedrals</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">index_map</span><span class="p">,</span> <span class="n">rd_torsion</span><span class="p">,</span> <span class="n">deg_abs</span><span class="o">=</span><span class="n">dihedral</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">force_field</span> <span class="o">!=</span> <span class="s1">&#39;gromacs&#39;</span><span class="p">:</span>
                <span class="n">xyz_</span><span class="p">,</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">get_force_field_energies</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz_dihedrals</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                        <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">energy</span> <span class="ow">and</span> <span class="n">xyz_</span><span class="p">:</span>
                    <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">optimize</span><span class="p">:</span>
                        <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_string</span><span class="p">(</span><span class="n">xyz_dihedrals</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_string</span><span class="p">(</span><span class="n">xyz_dihedrals</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span></div>


<div class="viewcode-block" id="determine_rotors"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.determine_rotors">[docs]</a><span class="k">def</span> <span class="nf">determine_rotors</span><span class="p">(</span><span class="n">mol_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine possible unique rotors in the species to be treated as hindered rotors.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol_list (list): Localized structures (Molecule objects) by which all rotors will be determined.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of indices of scan pivots.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: A list of indices of top atoms (including one of the pivotal atoms) corresponding to the torsions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">torsions</span><span class="p">,</span> <span class="n">tops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">mol_list</span><span class="p">:</span>
        <span class="n">rotors</span> <span class="o">=</span> <span class="n">find_internal_rotors</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">new_rotor</span> <span class="ow">in</span> <span class="n">rotors</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">existing_torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">existing_torsion</span> <span class="o">==</span> <span class="n">new_rotor</span><span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">]:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">torsions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_rotor</span><span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">])</span>
                <span class="n">tops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_rotor</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">torsions</span><span class="p">,</span> <span class="n">tops</span></div>


<div class="viewcode-block" id="determine_number_of_conformers_to_generate"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.determine_number_of_conformers_to_generate">[docs]</a><span class="k">def</span> <span class="nf">determine_number_of_conformers_to_generate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">heavy_atoms</span><span class="p">,</span> <span class="n">torsion_num</span><span class="p">,</span> <span class="n">minimalist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the number of conformers to generate using molecular mechanics</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        heavy_atoms (int): The number of heavy atoms in the molecule.</span>
<span class="sd">        torsion_num (int): The number of potential torsions in the molecule.</span>
<span class="sd">        minimalist (bool, optional): Whether to return a small number of conformers, useful when this is just a guess</span>
<span class="sd">                                     before fitting a force field. True to be minimalistic.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: number of conformers to generate.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ConformerError: If the number of conformers to generate cannot be determined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">torsion_num</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">torsion_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion_num</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">heavy_range</span><span class="p">,</span> <span class="n">num_confs_1</span> <span class="ow">in</span> <span class="n">CONFS_VS_HEAVY_ATOMS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">heavy_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;inf&#39;</span> <span class="ow">and</span> <span class="n">heavy_atoms</span> <span class="o">&gt;=</span> <span class="n">heavy_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">heavy_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">heavy_atoms</span> <span class="o">&gt;=</span> <span class="n">heavy_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Could not determine the number of conformers to generate according to the number &#39;</span>
                             <span class="s1">&#39;of heavy atoms (</span><span class="si">{heavy}</span><span class="s1">) in </span><span class="si">{label}</span><span class="s1">. The CONFS_VS_HEAVY_ATOMS dictionary might be &#39;</span>
                             <span class="s1">&#39;corrupt, got:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">heavy</span><span class="o">=</span><span class="n">heavy_atoms</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">CONFS_VS_HEAVY_ATOMS</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">torsion_range</span><span class="p">,</span> <span class="n">num_confs_2</span> <span class="ow">in</span> <span class="n">CONFS_VS_TORSIONS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">torsion_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;inf&#39;</span> <span class="ow">and</span> <span class="n">torsion_num</span> <span class="o">&gt;=</span> <span class="n">torsion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">torsion_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">torsion_num</span> <span class="o">&gt;=</span> <span class="n">torsion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Could not determine the number of conformers to generate according to the number &#39;</span>
                             <span class="s1">&#39;of torsions (</span><span class="si">{torsion_num}</span><span class="s1">) in </span><span class="si">{label}</span><span class="s1">. The CONFS_VS_TORSIONS dictionary might be &#39;</span>
                             <span class="s1">&#39;corrupt, got:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torsion_num</span><span class="o">=</span><span class="n">torsion_num</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="n">CONFS_VS_TORSIONS</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">minimalist</span><span class="p">:</span>
        <span class="n">num_confs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_confs_1</span><span class="p">,</span> <span class="n">num_confs_2</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_confs</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_confs_1</span><span class="p">,</span> <span class="n">num_confs_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">num_confs</span></div>


<div class="viewcode-block" id="determine_dihedrals"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.determine_dihedrals">[docs]</a><span class="k">def</span> <span class="nf">determine_dihedrals</span><span class="p">(</span><span class="n">conformers</span><span class="p">,</span> <span class="n">torsions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each conformer in `conformers` determine the respective dihedrals.</span>

<span class="sd">    Args:</span>
<span class="sd">        conformers (list): Entries are conformer dictionaries.</span>
<span class="sd">        torsions (list): All possible torsions in the molecule.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are conformer dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">conformers</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;torsion_dihedrals&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conformer</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;torsion_dihedrals&#39;</span><span class="p">]:</span>
            <span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;torsion_dihedrals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">calculate_dihedral_angle</span><span class="p">(</span><span class="n">coord</span><span class="o">=</span><span class="n">coord</span><span class="p">,</span> <span class="n">torsion</span><span class="o">=</span><span class="n">torsion</span><span class="p">)</span>
                <span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;torsion_dihedrals&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)]</span> <span class="o">=</span> <span class="n">angle</span>
    <span class="k">return</span> <span class="n">conformers</span></div>


<div class="viewcode-block" id="determine_torsion_sampling_points"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.determine_torsion_sampling_points">[docs]</a><span class="k">def</span> <span class="nf">determine_torsion_sampling_points</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">torsion_angles</span><span class="p">,</span> <span class="n">smeared_scan_res</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine how many points to consider in each well of a torsion for conformer combinations</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        torsion_angles (list): Well angles in the torsion.</span>
<span class="sd">        smeared_scan_res (float, optional): The resolution (in degrees) for scanning smeared wells.</span>
<span class="sd">        symmetry (int, optional): The torsion symmetry number.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Sampling points for the torsion.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: Each entry is a well dictionary with the keys</span>
<span class="sd">        ``start_idx``, ``end_idx``, ``start_angle``, ``end_angle``, ``angles``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smeared_scan_res</span> <span class="o">=</span> <span class="n">smeared_scan_res</span> <span class="ow">or</span> <span class="n">SMEARED_SCAN_RESOLUTIONS</span>
    <span class="n">sampling_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">wells</span> <span class="o">=</span> <span class="n">get_wells</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">torsion_angles</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">well</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wells</span><span class="p">):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;end_angle&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">well</span><span class="p">[</span><span class="s1">&#39;start_angle&#39;</span><span class="p">])</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">well</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">smeared_scan_res</span><span class="p">:</span>
            <span class="n">sampling_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="n">smeared_scan_res</span><span class="p">)</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mean</span> <span class="o">-</span> <span class="n">well</span><span class="p">[</span><span class="s1">&#39;start_angle&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="p">((</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">smeared_scan_res</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">sampling_points</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">padding</span> <span class="o">+</span> <span class="n">well</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">smeared_scan_res</span> <span class="o">*</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">))])</span>
        <span class="k">if</span> <span class="n">symmetry</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="o">/</span> <span class="n">symmetry</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">sampling_points</span><span class="p">,</span> <span class="n">wells</span></div>


<div class="viewcode-block" id="determine_torsion_symmetry"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.determine_torsion_symmetry">[docs]</a><span class="k">def</span> <span class="nf">determine_torsion_symmetry</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">top1</span><span class="p">,</span> <span class="n">mol_list</span><span class="p">,</span> <span class="n">torsion_scan</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether a torsion is symmetric.</span>

<span class="sd">    If a torsion well is &quot;well defined&quot; and not smeared, it could be symmetric.</span>
<span class="sd">    Check the groups attached to the rotor pivots to determine whether it is indeed symmetric</span>
<span class="sd">    We don&#39;t care about the actual rotor symmetry number here, since we plan to just use the first well</span>
<span class="sd">    (they&#39;re all the same).</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        top1 (list): A list of atom indices on one side of the torsion, including the pivotal atom.</span>
<span class="sd">        mol_list (list): A list of molecules.</span>
<span class="sd">        torsion_scan (list): The angles corresponding to this torsion from all conformers.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The rotor symmetry number.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">check_tops</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># flags for checking top1 and top2</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">mol_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">top2</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">top1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">top</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">top1</span><span class="p">,</span> <span class="n">top2</span><span class="p">]):</span>
        <span class="c1"># A quick bypass for methyl rotors which are too common:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isCarbon</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isHydrogen</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]):</span>
            <span class="n">symmetry</span> <span class="o">*=</span> <span class="mi">3</span>
            <span class="n">check_tops</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># A quick bypass for benzene rings:</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">11</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isCarbon</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)])</span> <span class="o">==</span> <span class="mi">6</span> \
                <span class="ow">and</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isHydrogen</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">11</span><span class="p">)])</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">symmetry</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">check_tops</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># treat the torsion list as cyclic, search for at least two blank parts of at least 60 degrees each</span>
    <span class="c1"># if the means of all data parts of the scan are uniformly scattered, the torsion might be symmetric</span>
    <span class="n">wells</span> <span class="o">=</span> <span class="n">get_wells</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="n">torsion_scan</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

    <span class="n">distances</span><span class="p">,</span> <span class="n">well_widths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wells</span><span class="p">)):</span>
        <span class="n">well_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">wells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;end_angle&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">wells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;start_angle&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">wells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;start_angle&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">wells</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;end_angle&#39;</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">mean_well_width</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">well_widths</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">well_widths</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wells</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">distance</span> <span class="o">==</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">])</span> \
            <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="n">mean_well_width</span><span class="p">)</span> <span class="o">/</span> <span class="n">mean_well_width</span> <span class="o">&lt;</span> <span class="n">determine_well_width_tolerance</span><span class="p">(</span><span class="n">mean_well_width</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">width</span> <span class="ow">in</span> <span class="n">well_widths</span><span class="p">]):</span>
        <span class="c1"># All well distances and widths are equal. The torsion scan might be symmetric, check the groups</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">top</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">top1</span><span class="p">,</span> <span class="n">top2</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">check_tops</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">groups</span><span class="p">,</span> <span class="n">grp_idx</span><span class="p">,</span> <span class="n">groups_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
                        <span class="n">atom_indices</span> <span class="o">=</span> <span class="n">determine_top_group_indices</span><span class="p">(</span>
                            <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom1</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">atom2</span><span class="o">=</span><span class="n">atom</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_group</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom_indices</span><span class="p">))</span>
                        <span class="n">grp_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_indices</span><span class="p">)</span>
                        <span class="n">groups_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">g</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">atom_indices</span><span class="p">])</span>
                <span class="c1"># hard-coding for NO2/NS2 groups, since the two O or S atoms have different atom types in each localized</span>
                <span class="c1"># structure, hence are not isomorphic</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomType</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;N5dc&#39;</span> \
                        <span class="ow">and</span> <span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomType</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;O2d&#39;</span><span class="p">,</span> <span class="s1">&#39;O0sc&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
                             <span class="ow">or</span> <span class="nb">all</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomType</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;S2d&#39;</span><span class="p">,</span> <span class="s1">&#39;S0sc&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])):</span>
                    <span class="n">symmetry</span> <span class="o">*=</span> <span class="mi">2</span>
                <span class="c1"># all other groups:</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lonePairs</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">radicalElectrons</span> <span class="o">&gt;</span> <span class="mi">0</span> \
                        <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isIsomorphic</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]):</span>
                    <span class="n">symmetry</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symmetry</span></div>


<div class="viewcode-block" id="determine_well_width_tolerance"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.determine_well_width_tolerance">[docs]</a><span class="k">def</span> <span class="nf">determine_well_width_tolerance</span><span class="p">(</span><span class="n">mean_width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the tolerance by which well widths are determined to be nearly equal.</span>

<span class="sd">    Fitted to a polynomial trend line for the following data of (mean, tolerance) pairs::</span>

<span class="sd">        (100, 0.11), (60, 0.13), (50, 0.15), (25, 0.25), (5, 0.50), (1, 0.59)</span>

<span class="sd">    Args:</span>
<span class="sd">        mean_width (float): The mean well width in degrees.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The tolerance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mean_width</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.1</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.695e-10</span> <span class="o">*</span> <span class="n">mean_width</span> <span class="o">**</span> <span class="mi">5</span> <span class="o">+</span> <span class="mf">6.209e-8</span> <span class="o">*</span> <span class="n">mean_width</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">-</span> <span class="mf">8.855e-6</span> <span class="o">*</span> <span class="n">mean_width</span> <span class="o">**</span> <span class="mi">3</span> \
        <span class="o">+</span> <span class="mf">6.446e-4</span> <span class="o">*</span> <span class="n">mean_width</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">2.610e-2</span> <span class="o">*</span> <span class="n">mean_width</span> <span class="o">+</span> <span class="mf">0.6155</span>
    <span class="k">return</span> <span class="n">tol</span></div>


<div class="viewcode-block" id="get_lowest_confs"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_lowest_confs">[docs]</a><span class="k">def</span> <span class="nf">get_lowest_confs</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">confs</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="s1">&#39;FF energy&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the most stable conformer</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        confs (list): Entries are either conformer dictionaries or a length two list of xyz coordinates and energy.</span>
<span class="sd">        n (int): Number of lowest conformers to return.</span>
<span class="sd">        energy (str, optional): The energy attribute to search by. Currently only &#39;FF energy&#39; is supported.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Conformer dictionaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">confs</span> <span class="ow">or</span> <span class="n">confs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;get_lowest_confs() got no conformers for </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">confs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">conformer_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">conformer</span> <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">confs</span> <span class="k">if</span> <span class="n">energy</span> <span class="ow">in</span> <span class="n">conformer</span> <span class="ow">and</span> <span class="n">conformer</span><span class="p">[</span><span class="n">energy</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nsmallest</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">conformer_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">conf</span><span class="p">:</span> <span class="n">conf</span><span class="p">[</span><span class="n">energy</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">confs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nsmallest</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">confs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">conf</span><span class="p">:</span> <span class="n">conf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s2">&quot;confs could either be a list of dictionaries or a list of lists. &quot;</span>
                             <span class="s2">&quot;Got a list of </span><span class="si">{0}</span><span class="s2">&#39;s for </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">confs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">label</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_torsion_angles"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_torsion_angles">[docs]</a><span class="k">def</span> <span class="nf">get_torsion_angles</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">conformers</span><span class="p">,</span> <span class="n">torsions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Populate each torsion pivots with all available angles from the generated conformers</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        conformers (list): The conformers from which to extract the angles.</span>
<span class="sd">        torsions (list): The torsions to consider.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The torsion angles. Keys are torsion tuples, values are lists of all corresponding angles from conformers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">torsion_angles</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;torsion_dihedrals&#39;</span> <span class="ow">in</span> <span class="n">conformer</span> <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">conformers</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Could not determine dihedral torsion angles for </span><span class="si">{0}</span><span class="s1">. &#39;</span>
                             <span class="s1">&#39;Consider calling `determine_dihedrals()` first.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">conformer</span> <span class="ow">in</span> <span class="n">conformers</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;torsion_dihedrals&#39;</span> <span class="ow">in</span> <span class="n">conformer</span> <span class="ow">and</span> <span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;torsion_dihedrals&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">torsion_angles</span><span class="p">:</span>
                    <span class="n">torsion_angles</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="n">torsion_angles</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conformer</span><span class="p">[</span><span class="s1">&#39;torsion_dihedrals&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">tor</span> <span class="ow">in</span> <span class="n">torsion_angles</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">torsion_angles</span><span class="p">[</span><span class="n">tor</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">torsion_angles</span></div>


<div class="viewcode-block" id="get_force_field_energies"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_force_field_energies">[docs]</a><span class="k">def</span> <span class="nf">get_force_field_energies</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                             <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine force field energies using RDKit.</span>
<span class="sd">    If num_confs is given, random 3D geometries will be generated. If xyz is given, it will be directly used instead.</span>
<span class="sd">    The coordinates are returned in the order of atoms in mol.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The RMG molecule object with connectivity and bond order information.</span>
<span class="sd">        num_confs (int, optional): The number of random 3D conformations to generate.</span>
<span class="sd">        xyz (string or list, optional): A 3D coordinates guess in either a string or an array format.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>
<span class="sd">        return_xyz_strings (bool, optional): Whether to return xyz in string or array format. True for string.</span>
<span class="sd">        optimize (bool, optional): Whether to first optimize the conformer using FF. True to optimize.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are xyz coordinates.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are the FF energies (in kJ/mol).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">force_field</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mmff94&#39;</span><span class="p">,</span> <span class="s1">&#39;mmff94s&#39;</span><span class="p">,</span> <span class="s1">&#39;uff&#39;</span><span class="p">]:</span>
        <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_index_map</span> <span class="o">=</span> <span class="n">embed_rdkit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="n">num_confs</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="n">rdkit_force_field</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="n">rd_index_map</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span>
                                           <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">force_field</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gaff&#39;</span><span class="p">,</span> <span class="s1">&#39;mmff94&#39;</span><span class="p">,</span> <span class="s1">&#39;mmff94s&#39;</span><span class="p">,</span> <span class="s1">&#39;uff&#39;</span><span class="p">,</span> <span class="s1">&#39;ghemical&#39;</span><span class="p">]:</span>
        <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="n">mix_rdkit_and_openbabel_force_field</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="n">num_confs</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
                                                             <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Unrecognized force field for </span><span class="si">{0}</span><span class="s1">. Should be either MMFF94, MMFF94s, UFF, Ghemical, &#39;</span>
                             <span class="s1">&#39;or GAFF. Got: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">force_field</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span></div>


<div class="viewcode-block" id="mix_rdkit_and_openbabel_force_field"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.mix_rdkit_and_openbabel_force_field">[docs]</a><span class="k">def</span> <span class="nf">mix_rdkit_and_openbabel_force_field</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;GAFF&#39;</span><span class="p">,</span>
                                        <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimize conformers using a force field (GAFF, MMFF94s, MMFF94, UFF, Ghemical)</span>
<span class="sd">    Use RDKit to generate the random conformers (open babel isn&#39;t good enough),</span>
<span class="sd">    but use open babel to optimize them (RDKit doesn&#39;t have GAFF)</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule, optional): The RMG molecule object with connectivity and bond order information.</span>
<span class="sd">        num_confs (int, optional): The number of random 3D conformations to generate.</span>
<span class="sd">        xyz (string or list, optional): The 3D coordinates in either a string or an array format.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>
<span class="sd">        return_xyz_strings (bool, optional): Whether to return xyz in string or array format. True for string.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are optimized xyz&#39;s in a list format.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are float numbers representing the energies in kJ/mol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_index_map</span> <span class="o">=</span> <span class="n">embed_rdkit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="n">num_confs</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">unoptimized_xyzs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rd_mol</span><span class="o">.</span><span class="n">GetNumConformers</span><span class="p">()):</span>
        <span class="n">conf</span><span class="p">,</span> <span class="n">xyz</span> <span class="o">=</span> <span class="n">rd_mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">GetAtomPosition</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">xyz</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="n">xyz</span><span class="p">[</span><span class="n">rd_index_map</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">)]</span>  <span class="c1"># reorder</span>
        <span class="n">unoptimized_xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>  <span class="c1"># in array form</span>

    <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">unoptimized_xyzs</span><span class="p">:</span>
        <span class="n">xyzs_</span><span class="p">,</span> <span class="n">energies_</span> <span class="o">=</span> <span class="n">openbabel_force_field</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span>
                                                 <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">)</span>
        <span class="n">xyzs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">xyzs_</span><span class="p">)</span>
        <span class="n">energies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">energies_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span></div>


<div class="viewcode-block" id="openbabel_force_field"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.openbabel_force_field">[docs]</a><span class="k">def</span> <span class="nf">openbabel_force_field</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;GAFF&#39;</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">method</span><span class="o">=</span><span class="s1">&#39;diverse&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimize conformers using a force field (GAFF, MMFF94s, MMFF94, UFF, Ghemical)</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule, optional): The RMG molecule object with connectivity and bond order information.</span>
<span class="sd">        num_confs (int, optional): The number of random 3D conformations to generate.</span>
<span class="sd">        xyz (list, optional): The 3D coordinates in an array format.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>
<span class="sd">        return_xyz_strings (bool, optional): Whether to return xyz in string or array format. True for string.</span>
<span class="sd">        method (str, optional): The conformer searching method to use in open babel.</span>
<span class="sd">                                         For method description, see http://openbabel.org/dev-api/group__conformer.shtml</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are optimized xyz&#39;s in a list format.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are float numbers representing the energies in kJ/mol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">ff</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">OBForceField</span><span class="o">.</span><span class="n">FindForceField</span><span class="p">(</span><span class="n">force_field</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># generate an open babel molecule</span>
        <span class="n">obmol</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">OBMol</span><span class="p">()</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span>
        <span class="n">ob_atom_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># dictionary of OB atom IDs</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">obmol</span><span class="o">.</span><span class="n">NewAtom</span><span class="p">()</span>
            <span class="n">a</span><span class="o">.</span><span class="n">SetAtomicNum</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">SetVector</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># assume xyz is ordered like mol; line not in in toOBMol</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">isotope</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">SetIsotope</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">isotope</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">SetFormalCharge</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="p">)</span>
            <span class="n">ob_atom_ids</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">GetId</span><span class="p">()</span>
        <span class="n">orders</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">isHydrogenBond</span><span class="p">():</span>
                    <span class="k">continue</span>
                <span class="n">index1</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span>
                <span class="n">index2</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index1</span> <span class="o">&lt;</span> <span class="n">index2</span><span class="p">:</span>
                    <span class="n">obmol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">index1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">orders</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">order</span><span class="p">])</span>

        <span class="c1"># optimize</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">SetLogLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">SetVDWCutOff</span><span class="p">(</span><span class="mf">6.0</span><span class="p">)</span>  <span class="c1"># The VDW cut-off distance (default=6.0)</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">SetElectrostaticCutOff</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>  <span class="c1"># The Electrostatic cut-off distance (default=10.0)</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">SetUpdateFrequency</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># The frequency to update the non-bonded pairs (default=10)</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">EnableCutOff</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Use cut-off (default=don&#39;t use cut-off)</span>
        <span class="c1"># ff.SetLineSearchType(&#39;Newton2Num&#39;)</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">SteepestDescentInitialize</span><span class="p">()</span>  <span class="c1"># ConjugateGradientsInitialize</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">SteepestDescentTakeNSteps</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># ConjugateGradientsTakeNSteps</span>
            <span class="k">if</span> <span class="n">ff</span><span class="o">.</span><span class="n">DetectExplosion</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Force field </span><span class="si">{0}</span><span class="s1"> exploded with method </span><span class="si">{1}</span><span class="s1"> for </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">force_field</span><span class="p">,</span> <span class="s1">&#39;SteepestDescent&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">GetCoordinates</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">num_confs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">obmol</span><span class="p">,</span> <span class="n">ob_atom_ids</span> <span class="o">=</span> <span class="n">toOBMol</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">returnMapping</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">pybmol</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">Molecule</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span>
        <span class="n">pybmol</span><span class="o">.</span><span class="n">make3D</span><span class="p">()</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;weighted&#39;</span><span class="p">:</span>
            <span class="n">ff</span><span class="o">.</span><span class="n">WeightedRotorSearch</span><span class="p">(</span><span class="n">num_confs</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">ff</span><span class="o">.</span><span class="n">RandomRotorSearch</span><span class="p">(</span><span class="n">num_confs</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;diverse&#39;</span><span class="p">:</span>
            <span class="n">rmsd_cutoff</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="n">energy_cutoff</span> <span class="o">=</span> <span class="mf">50.</span>
            <span class="n">confab_verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">ff</span><span class="o">.</span><span class="n">DiverseConfGen</span><span class="p">(</span><span class="n">rmsd_cutoff</span><span class="p">,</span> <span class="n">num_confs</span><span class="p">,</span> <span class="n">energy_cutoff</span><span class="p">,</span> <span class="n">confab_verbose</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;systematic&#39;</span><span class="p">:</span>
            <span class="n">ff</span><span class="o">.</span><span class="n">SystematicRotorSearch</span><span class="p">(</span><span class="n">num_confs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Could not identify method </span><span class="si">{0}</span><span class="s1"> for </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Either num_confs or xyz should be given for </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>

    <span class="n">ff</span><span class="o">.</span><span class="n">GetConformers</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span>
    <span class="n">obconversion</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">OBConversion</span><span class="p">()</span>
    <span class="n">obconversion</span><span class="o">.</span><span class="n">SetOutFormat</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">obmol</span><span class="o">.</span><span class="n">NumConformers</span><span class="p">()):</span>
        <span class="n">obmol</span><span class="o">.</span><span class="n">SetConformer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">Setup</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">obconversion</span><span class="o">.</span><span class="n">WriteString</span><span class="p">(</span><span class="n">obmol</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_xyz_strings</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="n">xyz</span><span class="p">[</span><span class="n">ob_atom_ids</span><span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">)]</span>  <span class="c1"># reorder</span>
        <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ff</span><span class="o">.</span><span class="n">Energy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span></div>


<div class="viewcode-block" id="embed_rdkit"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.embed_rdkit">[docs]</a><span class="k">def</span> <span class="nf">embed_rdkit</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">num_confs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random conformers (unoptimized) in RDKit</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (RMG Molecule or RDKit RDMol): The molecule object with connectivity and bond order information.</span>
<span class="sd">        num_confs (int, optional): The number of random 3D conformations to generate.</span>
<span class="sd">        xyz (string or list, optional): The 3D coordinates in either a string or an array format.</span>

<span class="sd">    Returns:</span>
<span class="sd">        RDMol: An RDKIt molecule with embedded conformers.</span>
<span class="sd">    Returns:</span>
<span class="sd">        dict: The atom mapping dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rd_index_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">num_confs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Either num_confs or xyz must be set when calling embed_rdkit() for </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">RDMol</span><span class="p">):</span>
        <span class="n">rd_mol</span> <span class="o">=</span> <span class="n">mol</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">):</span>
        <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_indices</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">to_rdkit_mol</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">remove_h</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_mapping</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">rd_indices</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>
            <span class="n">rd_index_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Argument mol can be either an RMG Molecule or an RDKit RDMol object. &#39;</span>
                             <span class="s1">&#39;Got </span><span class="si">{0}</span><span class="s1"> for </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="n">label</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">num_confs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">AllChem</span><span class="o">.</span><span class="n">EmbedMultipleConfs</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">numConfs</span><span class="o">=</span><span class="n">num_confs</span><span class="p">,</span> <span class="n">randomSeed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Chem.AllChem.EmbedMultipleConfs(rd_mol, numConfs=num_confs, randomSeed=15, enforceChirality=False)</span>
    <span class="k">elif</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rd_conf</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Conformer</span><span class="p">(</span><span class="n">rd_mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">xyz</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rd_mol</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()):</span>
            <span class="n">rd_conf</span><span class="o">.</span><span class="n">SetAtomPosition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">rd_mol</span><span class="o">.</span><span class="n">AddConformer</span><span class="p">(</span><span class="n">rd_conf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_index_map</span></div>


<div class="viewcode-block" id="read_rdkit_embedded_conformers"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.read_rdkit_embedded_conformers">[docs]</a><span class="k">def</span> <span class="nf">read_rdkit_embedded_conformers</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read coordinates from RDKit conformers.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        rd_mol (RDKit RDMol): The RDKit molecule with embedded conformers to optimize.</span>
<span class="sd">        i (int, optional): The conformer index from rd_mol to read. If None, all will be read,</span>
<span class="sd">        rd_index_map (list, optional): An atom map dictionary to reorder the xyz. Requires mol to not be None.</span>
<span class="sd">        mol (Molecule, optional): The RMG molecule object with connectivity and bond order information.</span>
<span class="sd">        return_xyz_strings (bool, optional): Whether to return xyz in string or array format. True for string.</span>
<span class="sd">                                             Requires mol to not be None to return string format.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: xyz coordinates in the desired format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyzs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># read all conformers:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rd_mol</span><span class="o">.</span><span class="n">GetNumConformers</span><span class="p">()):</span>
            <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">read_rdkit_embedded_conformer_i</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="n">rd_index_map</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span>
                                                        <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rd_mol</span><span class="o">.</span><span class="n">GetNumConformers</span><span class="p">():</span>
        <span class="c1"># read only conformer i:</span>
        <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">read_rdkit_embedded_conformer_i</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="n">rd_index_map</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span>
                                                    <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Cannot read conformer number &quot;</span><span class="si">{0}</span><span class="s1">&quot; out of </span><span class="si">{1}</span><span class="s1"> RDKit conformers for </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">rd_mol</span><span class="o">.</span><span class="n">GetNumConformers</span><span class="p">(),</span> <span class="n">label</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">xyzs</span></div>


<div class="viewcode-block" id="read_rdkit_embedded_conformer_i"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.read_rdkit_embedded_conformer_i">[docs]</a><span class="k">def</span> <span class="nf">read_rdkit_embedded_conformer_i</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read coordinates from RDKit conformers.</span>

<span class="sd">    Args:</span>
<span class="sd">        rd_mol (RDKit RDMol): The RDKit molecule with embedded conformers to optimize.</span>
<span class="sd">        i (int): The conformer index from rd_mol to read.</span>
<span class="sd">        rd_index_map (list, optional): An atom map dictionary to reorder the xyz. Requires mol to not be None.</span>
<span class="sd">        mol (Molecule, optional): The RMG molecule object with connectivity and bond order information.</span>
<span class="sd">        return_xyz_strings (bool, optional): Whether to return xyz in string or array format. True for string.</span>
<span class="sd">                                             Requires mol to not be None to return string format.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list or str: xyz coordinates in the desired format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conf</span><span class="p">,</span> <span class="n">xyz</span> <span class="o">=</span> <span class="n">rd_mol</span><span class="o">.</span><span class="n">GetConformer</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">GetNumAtoms</span><span class="p">()):</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">GetAtomPosition</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">rd_index_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="n">xyz</span><span class="p">[</span><span class="n">rd_index_map</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">)]</span>  <span class="c1"># reorder</span>
    <span class="k">if</span> <span class="n">return_xyz_strings</span> <span class="ow">and</span> <span class="n">mol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_string</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xyz</span></div>


<div class="viewcode-block" id="rdkit_force_field"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.rdkit_force_field">[docs]</a><span class="k">def</span> <span class="nf">rdkit_force_field</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="s1">&#39;MMFF94&#39;</span><span class="p">,</span> <span class="n">return_xyz_strings</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">optimize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimize RDKit conformers using a force field (MMFF94 or MMFF94s are recommended).</span>
<span class="sd">    Fallback to Open Babel if RDKit fails.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        rd_mol (RDKit RDMol): The RDKit molecule with embedded conformers to optimize.</span>
<span class="sd">        rd_index_map (list, optional): An atom map dictionary to reorder the xyz. Requires mol to not be None.</span>
<span class="sd">        mol (Molecule, optional): The RMG molecule object with connectivity and bond order information.</span>
<span class="sd">        force_field (str, optional): The type of force field to use.</span>
<span class="sd">        return_xyz_strings (bool, optional): Whether to return xyz in string or array format. True for string.</span>
<span class="sd">                                             Requires mol to not be None to return string format.</span>
<span class="sd">        optimize (bool, optional): Whether to first optimize the conformer using FF. True to optimize.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are optimized xyz&#39;s in the desired format.</span>
<span class="sd">    Returns:</span>
<span class="sd">        list: Entries are float numbers representing the energies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rd_mol</span><span class="o">.</span><span class="n">GetNumConformers</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">optimize</span><span class="p">:</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">v</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AllChem</span><span class="o">.</span><span class="n">MMFFOptimizeMolecule</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">mmffVariant</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">force_field</span><span class="p">),</span> <span class="n">confId</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                                                      <span class="n">maxIters</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">ignoreInterfragInteractions</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">mol_properties</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AllChem</span><span class="o">.</span><span class="n">MMFFGetMoleculeProperties</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">mmffVariant</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">force_field</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mol_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ff</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AllChem</span><span class="o">.</span><span class="n">MMFFGetMoleculeForceField</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">mol_properties</span><span class="p">,</span> <span class="n">confId</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">optimize</span><span class="p">:</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ff</span><span class="o">.</span><span class="n">CalcEnergy</span><span class="p">())</span>
            <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">read_rdkit_embedded_conformer_i</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="n">rd_index_map</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span>
                                                        <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyzs</span><span class="p">):</span>
        <span class="c1"># RDKit failed, try Open Babel</span>
        <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">xyzs</span> <span class="o">=</span> <span class="n">read_rdkit_embedded_conformers</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_index_map</span><span class="o">=</span><span class="n">rd_index_map</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span>
                                              <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">xyzs</span><span class="p">:</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">openbabel_force_field</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">force_field</span><span class="o">=</span><span class="n">force_field</span><span class="p">,</span>
                                                  <span class="n">return_xyz_strings</span><span class="o">=</span><span class="n">return_xyz_strings</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">xyzs</span><span class="p">,</span> <span class="n">energies</span></div>


<div class="viewcode-block" id="get_wells"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_wells">[docs]</a><span class="k">def</span> <span class="nf">get_wells</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">blank</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the distinct wells from a list of angles.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        angles (list): The angles in the torsion.</span>
<span class="sd">        blank (int, optional): The blank space between wells.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Each entry is a well dictionary with the keys: ``start_idx``, ``end_idx``, ``start_angle``, ``end_angle``,</span>
<span class="sd">        ``angles``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">angles</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Cannot determine wells without angles for </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="n">new_angles</span> <span class="o">=</span> <span class="n">angles</span>
    <span class="k">if</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">180</span> <span class="o">+</span> <span class="n">blank</span> <span class="ow">and</span> <span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">180</span> <span class="o">-</span> <span class="n">blank</span><span class="p">:</span>
        <span class="c1"># relocate the first chunk of data to the end, the well seems to include the  +180/-180 degrees point</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angles</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span> <span class="o">-</span> <span class="n">angles</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">blank</span><span class="p">:</span>
                <span class="n">part2</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">part2</span><span class="p">):</span>
                    <span class="n">part2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">360</span>
                <span class="n">new_angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">+</span> <span class="n">part2</span>
                <span class="k">break</span>
    <span class="n">wells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">new_well</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_angles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_well</span><span class="p">:</span>
            <span class="n">wells</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;start_idx&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                          <span class="s1">&#39;end_idx&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="s1">&#39;start_angle&#39;</span><span class="p">:</span> <span class="n">new_angles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                          <span class="s1">&#39;end_angle&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="s1">&#39;angles&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">()})</span>
            <span class="n">new_well</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">wells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_angles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">new_angles</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">new_angles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">blank</span><span class="p">:</span>
            <span class="c1"># This is the last point in this well</span>
            <span class="n">wells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;end_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">wells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;end_angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_well</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">wells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;end_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_angles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">wells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;end_angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">wells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">wells</span></div>


<div class="viewcode-block" id="check_atom_collisions"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.check_atom_collisions">[docs]</a><span class="k">def</span> <span class="nf">check_atom_collisions</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether atoms are too close to each other.</span>

<span class="sd">    Args:</span>
<span class="sd">        xyz (str): The 3D geometry.</span>

<span class="sd">    Returns:</span>
<span class="sd">         bool: True if they are colliding, False otherwise.</span>

<span class="sd">    Todo:</span>
<span class="sd">        - Consider atomic radius for the different elements</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyz</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">symbols</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">]:</span>
        <span class="c1"># hard-code for H2:</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coord1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coord2</span> <span class="ow">in</span> <span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">((</span><span class="n">coord1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">coord2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="mf">0.9</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="check_special_non_rotor_cases"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.check_special_non_rotor_cases">[docs]</a><span class="k">def</span> <span class="nf">check_special_non_rotor_cases</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">top1</span><span class="p">,</span> <span class="n">top2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether one of the tops correspond to a special case which could not be rotated</span>
<span class="sd">    `mol` is the RMG Molecule to diagnose</span>
<span class="sd">    `top1` and `top2` are indices of atoms on each side of the pivots, the first index corresponds to one of the pivots</span>

<span class="sd">    Special cases considered are:</span>

<span class="sd">    - cyano groups: ``R-C#N``</span>
<span class="sd">    - azide groups: ``N-N#N``</span>

<span class="sd">    These cases have a 180 degree angle and torsion is meaningless, but they are identified by our methods since they</span>
<span class="sd">    have a single bond</span>
<span class="sd">    Returns `True` if this is indeed a special case which should not be treated as a rotor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">top</span> <span class="ow">in</span> <span class="p">[</span><span class="n">top1</span><span class="p">,</span> <span class="n">top2</span><span class="p">]:</span>
        <span class="c1"># check cyano group</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isCarbon</span><span class="p">()</span> <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isNitrogen</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">top</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomType</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;N3t&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">tp1</span><span class="p">,</span> <span class="n">tp2</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">top1</span><span class="p">,</span> <span class="n">top2</span><span class="p">),</span> <span class="p">(</span><span class="n">top2</span><span class="p">,</span> <span class="n">top1</span><span class="p">)]:</span>
        <span class="c1"># check azide group</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tp1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tp1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomType</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;N5tc&#39;</span> \
                <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tp1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomType</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;N3t&#39;</span> <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">tp2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atomType</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;N1sc&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="determine_top_group_indices"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.determine_top_group_indices">[docs]</a><span class="k">def</span> <span class="nf">determine_top_group_indices</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the indices of a &quot;top group&quot; in a molecule.</span>
<span class="sd">    The top is defined as all atoms connected to atom2, including atom2, excluding the direction of atom1.</span>
<span class="sd">    Two ``atom_list_to_explore`` are used so the list the loop iterates through isn&#39;t changed within the loop.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The Molecule object to explore.</span>
<span class="sd">        atom1 (Atom): The pivotal atom in mol.</span>
<span class="sd">        atom2 (Atom): The beginning of the top relative to atom1 in mol.</span>
<span class="sd">        index (bool, optional): Whether to return 1-index or 0-index conventions. 1 for 1-index.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: The indices of the atoms in the top (either 0-index or 1-index, as requested).</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: Whether the top has heavy atoms (is not just a hydrogen atom). True if it has heavy atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">explored_atom_list</span><span class="p">,</span> <span class="n">atom_list_to_explore1</span><span class="p">,</span> <span class="n">atom_list_to_explore2</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom1</span><span class="p">],</span> <span class="p">[</span><span class="n">atom2</span><span class="p">],</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_list_to_explore1</span> <span class="o">+</span> <span class="n">atom_list_to_explore2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="n">atom_list_to_explore1</span><span class="p">:</span>
            <span class="n">top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom3</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom4</span> <span class="ow">in</span> <span class="n">atom3</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">atom4</span><span class="o">.</span><span class="n">isHydrogen</span><span class="p">():</span>
                    <span class="c1"># append H w/o further exploring</span>
                    <span class="n">top</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom4</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">atom4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored_atom_list</span> <span class="ow">and</span> <span class="n">atom4</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">atom_list_to_explore2</span><span class="p">:</span>
                    <span class="n">atom_list_to_explore2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom4</span><span class="p">)</span>  <span class="c1"># explore it further</span>
            <span class="n">explored_atom_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom3</span><span class="p">)</span>  <span class="c1"># mark as explored</span>
        <span class="n">atom_list_to_explore1</span><span class="p">,</span> <span class="n">atom_list_to_explore2</span> <span class="o">=</span> <span class="n">atom_list_to_explore2</span><span class="p">,</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">,</span> <span class="ow">not</span> <span class="n">atom2</span><span class="o">.</span><span class="n">isHydrogen</span><span class="p">()</span></div>


<div class="viewcode-block" id="find_internal_rotors"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.find_internal_rotors">[docs]</a><span class="k">def</span> <span class="nf">find_internal_rotors</span><span class="p">(</span><span class="n">mol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Locates the sets of indices corresponding to every internal rotor.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The molecule for which rotors will be determined</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: All rotor dictionaries with the gaussian scan coordinates, the pivots and the smallest top.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rotors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">isNonHydrogen</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">atom2</span><span class="o">.</span><span class="n">isNonHydrogen</span><span class="p">()</span> <span class="ow">and</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span> \
                        <span class="ow">and</span> <span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">isSingle</span><span class="p">()</span> <span class="ow">or</span> <span class="n">bond</span><span class="o">.</span><span class="n">isHydrogenBond</span><span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mol</span><span class="o">.</span><span class="n">isBondInCycle</span><span class="p">(</span><span class="n">bond</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom2</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># none of the pivotal atoms are terminal</span>
                        <span class="n">rotor</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                        <span class="c1"># pivots:</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;pivots&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># top:</span>
                        <span class="n">top1</span><span class="p">,</span> <span class="n">top1_has_heavy_atoms</span> <span class="o">=</span> <span class="n">determine_top_group_indices</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">atom1</span><span class="p">)</span>
                        <span class="n">top2</span><span class="p">,</span> <span class="n">top2_has_heavy_atoms</span> <span class="o">=</span> <span class="n">determine_top_group_indices</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">)</span>
                        <span class="n">non_rotor</span> <span class="o">=</span> <span class="n">check_special_non_rotor_cases</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">top1</span><span class="p">,</span> <span class="n">top2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">non_rotor</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">top1_has_heavy_atoms</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">top2_has_heavy_atoms</span><span class="p">:</span>
                            <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top2</span>
                        <span class="k">elif</span> <span class="n">top2_has_heavy_atoms</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">top1_has_heavy_atoms</span><span class="p">:</span>
                            <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">top1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">top2</span><span class="p">)</span> <span class="k">else</span> <span class="n">top2</span>
                        <span class="c1"># scan:</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">heavy_atoms</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">atom3</span><span class="o">.</span><span class="n">isHydrogen</span><span class="p">():</span>
                                <span class="n">hydrogens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom3</span><span class="p">))</span>
                            <span class="k">elif</span> <span class="n">atom3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">atom2</span><span class="p">:</span>
                                <span class="n">heavy_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom3</span><span class="p">))</span>
                        <span class="n">smallest_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heavy_atoms</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">heavy_atoms</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smallest_index</span><span class="p">:</span>
                                    <span class="n">smallest_index</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smallest_index</span><span class="p">:</span>
                                    <span class="n">smallest_index</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smallest_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">heavy_atoms</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">hydrogens</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">atom3</span> <span class="ow">in</span> <span class="n">atom2</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">atom3</span><span class="o">.</span><span class="n">isHydrogen</span><span class="p">():</span>
                                <span class="n">hydrogens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom3</span><span class="p">))</span>
                            <span class="k">elif</span> <span class="n">atom3</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">atom1</span><span class="p">:</span>
                                <span class="n">heavy_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom3</span><span class="p">))</span>
                        <span class="n">smallest_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heavy_atoms</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">heavy_atoms</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smallest_index</span><span class="p">:</span>
                                    <span class="n">smallest_index</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hydrogens</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smallest_index</span><span class="p">:</span>
                                    <span class="n">smallest_index</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smallest_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;invalidation_reason&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;times_dihedral_set&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">rotor</span><span class="p">[</span><span class="s1">&#39;scan_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                        <span class="n">rotors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rotors</span></div>


<div class="viewcode-block" id="to_group"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.to_group">[docs]</a><span class="k">def</span> <span class="nf">to_group</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom_indices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method converts a defined part of a Molecule into a Group.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The base molecule.</span>
<span class="sd">        atom_indices (list): 0-indexed atom indices corresponding to atoms in mol to be included in the group.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Group: A group consisting of the desired atoms in mol.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create GroupAtom object for each atom in the molecule</span>
    <span class="n">group_atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">index_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># keys are Molecule atom indices, values are Group atom indices</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_indices</span><span class="p">):</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]</span>
        <span class="n">group_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gr</span><span class="o">.</span><span class="n">GroupAtom</span><span class="p">(</span><span class="n">atomType</span><span class="o">=</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">atomType</span><span class="p">],</span> <span class="n">radicalElectrons</span><span class="o">=</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">radicalElectrons</span><span class="p">],</span>
                                        <span class="n">charge</span><span class="o">=</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">charge</span><span class="p">],</span> <span class="n">lonePairs</span><span class="o">=</span><span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">lonePairs</span><span class="p">]))</span>
        <span class="n">index_map</span><span class="p">[</span><span class="n">atom_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">Group</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">group_atoms</span><span class="p">,</span> <span class="n">multiplicity</span><span class="o">=</span><span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="c1"># Create a GroupBond for each bond between desired atoms in the molecule</span>
        <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="ow">in</span> <span class="n">atom_indices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bonded_atom</span><span class="p">,</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bonded_atom</span><span class="p">)</span> <span class="ow">in</span> <span class="n">atom_indices</span><span class="p">:</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">addBond</span><span class="p">(</span><span class="n">gr</span><span class="o">.</span><span class="n">GroupBond</span><span class="p">(</span><span class="n">group_atoms</span><span class="p">[</span><span class="n">index_map</span><span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">)]],</span>
                                               <span class="n">group_atoms</span><span class="p">[</span><span class="n">index_map</span><span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bonded_atom</span><span class="p">)]],</span>
                                               <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="n">bond</span><span class="o">.</span><span class="n">order</span><span class="p">]))</span>
    <span class="n">group</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">group</span></div>


<div class="viewcode-block" id="update_mol"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.update_mol">[docs]</a><span class="k">def</span> <span class="nf">update_mol</span><span class="p">(</span><span class="n">mol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update atom types, multiplicity, and atom charges in the molecule.</span>
<span class="sd">    *untested*</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The molecule to update.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Molecule: the updated molecule.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">updateCharge</span><span class="p">()</span>
    <span class="n">mol</span><span class="o">.</span><span class="n">updateAtomTypes</span><span class="p">(</span><span class="n">logSpecies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">mol</span><span class="o">.</span><span class="n">updateMultiplicity</span><span class="p">()</span>
    <span class="n">mol</span><span class="o">.</span><span class="n">identifyRingMembership</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mol</span></div>


<div class="viewcode-block" id="compare_xyz"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.compare_xyz">[docs]</a><span class="k">def</span> <span class="nf">compare_xyz</span><span class="p">(</span><span class="n">xyz1</span><span class="p">,</span> <span class="n">xyz2</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare coordinates of two conformers of the same species</span>

<span class="sd">    Args:</span>
<span class="sd">        xyz1 (list, str): Coordinates of conformer 1 in either string or array format.</span>
<span class="sd">        xyz2 (list, str): Coordinates of conformer 2 in either string or array format.</span>
<span class="sd">        precision (float, optional): The allowed difference threshold between coordinates, in Angstroms.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: Whether the coordinates represent the same conformer, True if they do.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz1</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="n">xyz1</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz2</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">unicode</span><span class="p">)):</span>
        <span class="n">xyz2</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="p">[</span><span class="n">xyz1</span><span class="p">,</span> <span class="n">xyz2</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;xyz1 and xyz2 can either be string or list formats, got </span><span class="si">{0}</span><span class="s1"> and </span><span class="si">{1}</span><span class="s1">, respectively&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">xyz1</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">xyz2</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xyz1</span><span class="p">,</span> <span class="n">xyz2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">entry1</span><span class="p">,</span> <span class="n">entry2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">entry1</span> <span class="o">-</span> <span class="n">entry2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="generate_all_enantiomers"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.generate_all_enantiomers">[docs]</a><span class="k">def</span> <span class="nf">generate_all_enantiomers</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all combinations of enantiomers for a given conformer&#39;s coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The 2D graph representation of the molecule.</span>
<span class="sd">        xyz (str): A string-format 3d coordinates of the molecule with the same atom order as in mol.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of string-format coordinates of all enantiomer combinations.</span>

<span class="sd">    Todo:</span>
<span class="sd">        - Consider cases where the chiral center has three or four of its groups in a ring, e.g.,</span>
<span class="sd">          &#39;CC12C[CH]C(CC1)C(C)(C)O2&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coords</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">optical_isomers</span> <span class="o">=</span> <span class="n">determine_symmetry</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">optical_isomers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">pivots</span> <span class="o">=</span> <span class="n">identify_chiral_centers</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">pivot_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">pivots</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pivots</span><span class="p">)))</span>  <span class="c1"># e.g., [(5, 5), (5, 6), (6, 6)]</span>
    <span class="n">pivot_combinations</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">comb</span><span class="p">))</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">pivot_combinations</span><span class="p">]</span>  <span class="c1"># remove dups, i.e., convert (6, 6) to [6]</span>
    <span class="k">if</span> <span class="n">pivot_combinations</span> <span class="o">==</span> <span class="p">[[]]:</span>
        <span class="n">pivot_combinations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Identified </span><span class="si">{0}</span><span class="s1"> enantiomeric combinations for </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pivot_combinations</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
    <span class="n">xyzs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">pivots</span> <span class="ow">in</span> <span class="n">pivot_combinations</span><span class="p">:</span>
        <span class="n">new_xyz</span> <span class="o">=</span> <span class="n">xyz</span>
        <span class="k">for</span> <span class="n">pivot</span> <span class="ow">in</span> <span class="n">pivots</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_xyz</span> <span class="o">=</span> <span class="n">translate_groups</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">new_xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ConformerError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Could not translate all groups of species </span><span class="si">{0}</span><span class="s1"> (perhaps there are too many groups &#39;</span>
                               <span class="s1">&#39;bound in rings), cannot generate all enantiomers.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
        <span class="n">xyzs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_xyz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xyzs</span></div>


<div class="viewcode-block" id="identify_chiral_centers"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.identify_chiral_centers">[docs]</a><span class="k">def</span> <span class="nf">identify_chiral_centers</span><span class="p">(</span><span class="n">mol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identify the atom indices corresponding to chiral centers in a molecule</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The molecule to be analyzed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: Atom numbers (0-indexed) representing chiral centers in the molecule.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># legacy chirality:</span>
    <span class="n">rd_index_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">rd_mol</span><span class="p">,</span> <span class="n">rd_indices</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">to_rdkit_mol</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">remove_h</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_mapping</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">rd_indices</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>
        <span class="n">rd_index_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
    <span class="n">AssignStereochemistry</span><span class="p">(</span><span class="n">rd_mol</span><span class="p">,</span> <span class="n">flagPossibleStereoCenters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rd_atom_chirality_flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">HasProp</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;_ChiralityPossible&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">rd_mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()]</span>
    <span class="n">chiral_centers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">flag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rd_atom_chirality_flags</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">chiral_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rd_index_map</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># nitrogen umbrella modes:</span>
    <span class="k">for</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atom1</span><span class="o">.</span><span class="n">isNitrogen</span><span class="p">()</span> <span class="ow">and</span> <span class="n">atom1</span><span class="o">.</span><span class="n">lonePairs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">atom1</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">determine_top_group_indices</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_group</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">top</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isIsomorphic</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">+</span>
                   <span class="p">[</span><span class="ow">not</span> <span class="n">groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isIsomorphic</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]):</span>
                <span class="c1"># if we can say that TWO groups, each separately considered ins&#39;t isomorphic to the other two,</span>
                <span class="c1"># then this nitrogen has all different (three) groups.</span>
                <span class="n">chiral_centers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">chiral_centers</span></div>


<div class="viewcode-block" id="translate_groups"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.translate_groups">[docs]</a><span class="k">def</span> <span class="nf">translate_groups</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exchange between two groups in a molecule. The groups cannot share a ring with the pivotal atom.</span>
<span class="sd">    The function does not change the atom order, just the coordinates of atoms.</span>
<span class="sd">    If the pivotal atom has exactly one lone pair, consider it as well as a dummy atom in translations.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The 2D graph representation of the molecule.</span>
<span class="sd">        xyz (str): A string-format 3d coordinates of the molecule with the same atom order as in mol.</span>
<span class="sd">        pivot (int): The 0-index of the pivotal atom around which groups are to be translated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol</span><span class="o">.</span><span class="n">identifyRingMembership</span><span class="p">()</span>  <span class="c1"># populates the Atom.props[&#39;inRing&#39;] attribute</span>
    <span class="n">atom1</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">lonePairs</span>
    <span class="k">if</span> <span class="n">lp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Cannot translate groups for </span><span class="si">{0}</span><span class="s1"> if the pivotal atom has more than one &#39;</span>
                       <span class="s1">&#39;lone electron pair&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">xyz</span>
    <span class="n">groups</span><span class="p">,</span> <span class="n">translate</span><span class="p">,</span> <span class="n">dont_translate</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">determine_top_group_indices</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;atom&#39;</span><span class="p">:</span> <span class="n">atom2</span><span class="p">,</span> <span class="s1">&#39;protons&#39;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top</span><span class="p">])})</span>  <span class="c1"># a dict per top</span>
        <span class="k">if</span> <span class="s1">&#39;inRing&#39;</span> <span class="ow">in</span> <span class="n">atom1</span><span class="o">.</span><span class="n">props</span> <span class="ow">and</span> <span class="n">atom1</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;inRing&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="s1">&#39;inRing&#39;</span> <span class="ow">in</span> <span class="n">atom2</span><span class="o">.</span><span class="n">props</span> <span class="ow">and</span> <span class="n">atom2</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s1">&#39;inRing&#39;</span><span class="p">]:</span>
            <span class="c1"># check whether atom1 and atom2 belong to the same ring</span>
            <span class="n">sssr</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">getSmallestSetOfSmallestRings</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">sssr</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="n">ring</span> <span class="ow">and</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">:</span>
                    <span class="n">dont_translate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom2</span><span class="p">)</span>
                    <span class="k">break</span>
    <span class="n">groups</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;protons&#39;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># sort by the size (sum of atomic numbers)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">translate</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">lp</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dont_translate</span><span class="p">:</span>
            <span class="n">translate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">translate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lp</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">get_lp_vector</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">)</span>
        <span class="n">new_xyz</span> <span class="o">=</span> <span class="n">translate_group</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">,</span>
                                  <span class="n">anchor</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">translate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]),</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">translate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lp</span><span class="p">:</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">get_vector</span><span class="p">(</span><span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">translate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]),</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">new_xyz</span> <span class="o">=</span> <span class="n">translate_group</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">,</span>
                                  <span class="n">anchor</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">translate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]),</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span>
        <span class="n">vector</span> <span class="o">=</span> <span class="n">get_vector</span><span class="p">(</span><span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">translate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]),</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>  <span class="c1"># keep original xyz</span>
        <span class="n">new_xyz</span> <span class="o">=</span> <span class="n">translate_group</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">new_xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">,</span>
                                  <span class="n">anchor</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">translate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]),</span> <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;The number of groups to translate is </span><span class="si">{0}</span><span class="s1">, expected 1 (with a lone pair) &#39;</span>
                                 <span class="s1">&#39;for </span><span class="si">{1}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">translate</span><span class="p">),</span> <span class="n">label</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;The number of groups to translate is </span><span class="si">{0}</span><span class="s1">, expected 2 for </span><span class="si">{1}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">translate</span><span class="p">),</span> <span class="n">label</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_xyz</span></div>


<div class="viewcode-block" id="translate_group"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.translate_group">[docs]</a><span class="k">def</span> <span class="nf">translate_group</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">anchor</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate a group (a set of atoms from the pivot towards the anchor and onwards) by changing its</span>
<span class="sd">    pivot -&gt; anchor vector to the desired new vector. Keep the relative distances between the group&#39;s atoms constant,</span>
<span class="sd">    as well as the distance between the anchor and the vector atoms.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): The 2D graph representation of the molecule.</span>
<span class="sd">        xyz (str): A string-format 3d coordinates of the molecule with the same atom order as in mol.</span>
<span class="sd">        pivot (int): The 0-index of the pivotal atom around which groups are to be translated.</span>
<span class="sd">        anchor (int): The 0-index of an anchor atom. The group is defined from the pivot atom to the anchor atom,</span>
<span class="sd">                      including all other atoms in the molecule connected to the anchor. The pivot and anchor</span>
<span class="sd">                      atoms should not have another path connecting them such as a ring.</span>
<span class="sd">        vector (list): The new vector by which the group will be translated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The translated coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># v1 = unit_vector([-vector[0], -vector[1], -vector[2]])  # reverse the direction to get the correct angle</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">get_vector</span><span class="p">(</span><span class="n">pivot</span><span class="o">=</span><span class="n">pivot</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="n">anchor</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">))</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">get_normal</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">get_theta</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
    <span class="c1"># print(theta * 180 / math.pi)  # print theta in degrees when troubleshooting</span>
    <span class="c1"># All atoms within the group will be rotated around the same normal vector by theta:</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">determine_top_group_indices</span><span class="p">(</span><span class="n">mol</span><span class="o">=</span><span class="n">mol</span><span class="p">,</span> <span class="n">atom1</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">atom2</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">anchor</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coords</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotate_vector</span><span class="p">(</span><span class="n">point_a</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">point_b</span><span class="o">=</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">normal</span><span class="o">=</span><span class="n">normal</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">new_xyz</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_string</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_xyz</span></div>


<div class="viewcode-block" id="get_normal"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_normal">[docs]</a><span class="k">def</span> <span class="nf">get_normal</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a normal vector using cross multiplication.</span>

<span class="sd">    Args:</span>
<span class="sd">         v1 (list): Vector 1.</span>
<span class="sd">         v2 (list): Vector 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A normal unit vector to v1 and v2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">-</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_theta"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_theta">[docs]</a><span class="k">def</span> <span class="nf">get_theta</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the angle in radians between two vectors.</span>

<span class="sd">    Args:</span>
<span class="sd">         v1 (list): Vector 1.</span>
<span class="sd">         v2 (list): Vector 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The angle in radians between v1 and v2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v2</span><span class="p">)))</span></div>


<div class="viewcode-block" id="unit_vector"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.unit_vector">[docs]</a><span class="k">def</span> <span class="nf">unit_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a unit vector in the same direction as the input vector.</span>

<span class="sd">    Args:</span>
<span class="sd">        vector (list): The input vector.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: The unit vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">v</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">])</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">unit_vector_</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">/</span> <span class="n">length</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">unit_vector_</span></div>


<div class="viewcode-block" id="rotate_vector"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.rotate_vector">[docs]</a><span class="k">def</span> <span class="nf">rotate_vector</span><span class="p">(</span><span class="n">point_a</span><span class="p">,</span> <span class="n">point_b</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate a vector in 3D space around a given axis by a certain angle.</span>

<span class="sd">    Inspired by https://stackoverflow.com/questions/6802577/rotation-of-3d-vector</span>

<span class="sd">    Args:</span>
<span class="sd">        point_a (list): The 3D coordinates of the starting point (point A) of the vector to be rotated.</span>
<span class="sd">        point_b (list): The 3D coordinates of the ending point (point B) of the vector to be rotated.</span>
<span class="sd">        normal (list): The axis to be rotated around.</span>
<span class="sd">        theta (float): The degree in radians by which to rotate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: The rotated vector (the new coordinates for point B).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">normal</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span>
    <span class="n">bc</span><span class="p">,</span> <span class="n">ad</span><span class="p">,</span> <span class="n">ac</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">cd</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">aa</span> <span class="o">+</span> <span class="n">bb</span> <span class="o">-</span> <span class="n">cc</span> <span class="o">-</span> <span class="n">dd</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bc</span> <span class="o">+</span> <span class="n">ad</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bd</span> <span class="o">-</span> <span class="n">ac</span><span class="p">)],</span>
                                <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bc</span> <span class="o">-</span> <span class="n">ad</span><span class="p">),</span> <span class="n">aa</span> <span class="o">+</span> <span class="n">cc</span> <span class="o">-</span> <span class="n">bb</span> <span class="o">-</span> <span class="n">dd</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">cd</span> <span class="o">+</span> <span class="n">ab</span><span class="p">)],</span>
                                <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bd</span> <span class="o">+</span> <span class="n">ac</span><span class="p">),</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">cd</span> <span class="o">-</span> <span class="n">ab</span><span class="p">),</span> <span class="n">aa</span> <span class="o">+</span> <span class="n">dd</span> <span class="o">-</span> <span class="n">bb</span> <span class="o">-</span> <span class="n">cc</span><span class="p">]])</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">point_b</span><span class="p">,</span> <span class="n">point_a</span><span class="p">)]</span>
    <span class="n">new_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">new_vector</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_v</span> <span class="o">+</span> <span class="n">a</span> <span class="k">for</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_vector</span><span class="p">,</span> <span class="n">point_a</span><span class="p">)]</span>  <span class="c1"># root the vector at the original starting point</span>
    <span class="k">return</span> <span class="n">new_vector</span></div>


<div class="viewcode-block" id="get_vector"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_vector">[docs]</a><span class="k">def</span> <span class="nf">get_vector</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">anchor</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a vector between two atoms in the molecule (pointing from pivot to anchor).</span>

<span class="sd">    Args:</span>
<span class="sd">        pivot (int): The 0-index of the pivotal atom around which groups are to be translated.</span>
<span class="sd">        anchor (int): The 0-index of an additional atom in the molecule.</span>
<span class="sd">        xyz (str): A string-format 3d coordinates of the molecule with the same atom order as in mol.</span>

<span class="sd">    Returns:</span>
<span class="sd">         list: A vector pointing from the pivotal atom towards the anchor atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">anchor</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">anchor</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span>
    <span class="n">dz</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">anchor</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_lp_vector"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.get_lp_vector">[docs]</a><span class="k">def</span> <span class="nf">get_lp_vector</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">pivot</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a vector from the pivotal atom in the molecule towards its lone electron pairs.</span>
<span class="sd">    The approach is to reverse the average of the three unit vectors between the pivotal atom and its neighbors.</span>

<span class="sd">    Args:</span>
<span class="sd">        label (str): The species&#39; label.</span>
<span class="sd">        mol (Molecule): The 2D graph representation of the molecule.</span>
<span class="sd">        xyz (str): A string-format 3d coordinates of the molecule with the same atom order as in mol.</span>
<span class="sd">        pivot (int): The 0-index of the pivotal atom around which groups are to be translated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A vector pointing from the pivotal atom towards its lone electron pairs orbital.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">neighbors</span><span class="p">,</span> <span class="n">vectors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># N will have 3, S may have more.</span>
        <span class="k">raise</span> <span class="n">ConformerError</span><span class="p">(</span><span class="s1">&#39;Can only get lp vector if the pivotal atom has at least three neighbors. &#39;</span>
                             <span class="s1">&#39;Atom </span><span class="si">{0}</span><span class="s1"> in </span><span class="si">{1}</span><span class="s1"> has only </span><span class="si">{2}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">get_xyz_matrix</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>  <span class="c1"># already taken in &quot;reverse&quot;, pointing towards the lone pair</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">-</span> <span class="n">z</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>
        <span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unit_vector</span><span class="p">([</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">]))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">vectors</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>  <span class="c1"># average</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">vectors</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">z</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">vectors</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">vector</span></div>


<div class="viewcode-block" id="calculate_dihedral_angle"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.calculate_dihedral_angle">[docs]</a><span class="k">def</span> <span class="nf">calculate_dihedral_angle</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">torsion</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a dihedral angle. Inspired by ASE Atoms.get_dihedral().</span>

<span class="sd">    Args:</span>
<span class="sd">        coord (list): The array-format coordinates.</span>
<span class="sd">        torsion (list): The 4 atoms defining the dihedral angle.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The dihedral angle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">torsion</span><span class="p">]</span>  <span class="c1"># convert 1-index to 0-index</span>
    <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="n">torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">coord</span><span class="p">[</span><span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">-</span> <span class="n">coord</span><span class="p">[</span><span class="n">torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="n">torsion</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">-</span> <span class="n">coord</span><span class="p">[</span><span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">bxa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">bxa</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bxa</span><span class="p">)</span>
    <span class="n">cxb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">cxb</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cxb</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">bxa</span><span class="p">,</span> <span class="n">cxb</span><span class="p">)</span>
    <span class="c1"># check for numerical trouble due to finite precision:</span>
    <span class="k">if</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">bxa</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">angle</span>
    <span class="k">return</span> <span class="n">angle</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span></div>


<div class="viewcode-block" id="initialize_log"><a class="viewcode-back" href="../../../api/conformers.html#arc.species.conformers.initialize_log">[docs]</a><span class="k">def</span> <span class="nf">initialize_log</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set up a simple logger for stdout printing (not saving into as log file).</span>

<span class="sd">    Args:</span>
<span class="sd">        verbose (int, optional): Specify the amount of log text seen.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Use custom level names for cleaner log output</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span> <span class="s1">&#39;Critical: &#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="s1">&#39;Error: &#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span> <span class="s1">&#39;Warning: &#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">addLevelName</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># Create formatter and add to handlers</span>
    <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(levelname)s%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Remove old handlers before adding ours</span>
    <span class="k">while</span> <span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">removeHandler</span><span class="p">(</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Create console handler; send everything to stdout rather than stderr</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
    <span class="n">ch</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018-2019, Alon Grinberg Dana

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>